
GccApplication18.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000014c  00800200  00000f72  00001006  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f72  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000e  0080034c  0080034c  00001152  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001152  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001184  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000190  00000000  00000000  000011c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000307b  00000000  00000000  00001354  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000120f  00000000  00000000  000043cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000164d  00000000  00000000  000055de  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000034c  00000000  00000000  00006c2c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000a3a  00000000  00000000  00006f78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000017f3  00000000  00000000  000079b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000160  00000000  00000000  000091a5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	f1 c0       	rjmp	.+482    	; 0x1e4 <__ctors_end>
   2:	00 00       	nop
   4:	0e c1       	rjmp	.+540    	; 0x222 <__bad_interrupt>
   6:	00 00       	nop
   8:	0c c1       	rjmp	.+536    	; 0x222 <__bad_interrupt>
   a:	00 00       	nop
   c:	0a c1       	rjmp	.+532    	; 0x222 <__bad_interrupt>
   e:	00 00       	nop
  10:	08 c1       	rjmp	.+528    	; 0x222 <__bad_interrupt>
  12:	00 00       	nop
  14:	06 c1       	rjmp	.+524    	; 0x222 <__bad_interrupt>
  16:	00 00       	nop
  18:	04 c1       	rjmp	.+520    	; 0x222 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	02 c1       	rjmp	.+516    	; 0x222 <__bad_interrupt>
  1e:	00 00       	nop
  20:	00 c1       	rjmp	.+512    	; 0x222 <__bad_interrupt>
  22:	00 00       	nop
  24:	fe c0       	rjmp	.+508    	; 0x222 <__bad_interrupt>
  26:	00 00       	nop
  28:	fc c0       	rjmp	.+504    	; 0x222 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	fa c0       	rjmp	.+500    	; 0x222 <__bad_interrupt>
  2e:	00 00       	nop
  30:	f8 c0       	rjmp	.+496    	; 0x222 <__bad_interrupt>
  32:	00 00       	nop
  34:	f6 c0       	rjmp	.+492    	; 0x222 <__bad_interrupt>
  36:	00 00       	nop
  38:	f4 c0       	rjmp	.+488    	; 0x222 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	f2 c0       	rjmp	.+484    	; 0x222 <__bad_interrupt>
  3e:	00 00       	nop
  40:	f0 c0       	rjmp	.+480    	; 0x222 <__bad_interrupt>
  42:	00 00       	nop
  44:	ee c0       	rjmp	.+476    	; 0x222 <__bad_interrupt>
  46:	00 00       	nop
  48:	ec c0       	rjmp	.+472    	; 0x222 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	ea c0       	rjmp	.+468    	; 0x222 <__bad_interrupt>
  4e:	00 00       	nop
  50:	e8 c0       	rjmp	.+464    	; 0x222 <__bad_interrupt>
  52:	00 00       	nop
  54:	e6 c0       	rjmp	.+460    	; 0x222 <__bad_interrupt>
  56:	00 00       	nop
  58:	e4 c0       	rjmp	.+456    	; 0x222 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	e2 c0       	rjmp	.+452    	; 0x222 <__bad_interrupt>
  5e:	00 00       	nop
  60:	e0 c0       	rjmp	.+448    	; 0x222 <__bad_interrupt>
  62:	00 00       	nop
  64:	de c0       	rjmp	.+444    	; 0x222 <__bad_interrupt>
  66:	00 00       	nop
  68:	dc c0       	rjmp	.+440    	; 0x222 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	da c0       	rjmp	.+436    	; 0x222 <__bad_interrupt>
  6e:	00 00       	nop
  70:	d8 c0       	rjmp	.+432    	; 0x222 <__bad_interrupt>
  72:	00 00       	nop
  74:	d6 c0       	rjmp	.+428    	; 0x222 <__bad_interrupt>
  76:	00 00       	nop
  78:	d4 c0       	rjmp	.+424    	; 0x222 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	d2 c0       	rjmp	.+420    	; 0x222 <__bad_interrupt>
  7e:	00 00       	nop
  80:	d0 c0       	rjmp	.+416    	; 0x222 <__bad_interrupt>
  82:	00 00       	nop
  84:	ce c0       	rjmp	.+412    	; 0x222 <__bad_interrupt>
  86:	00 00       	nop
  88:	cc c0       	rjmp	.+408    	; 0x222 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	ca c0       	rjmp	.+404    	; 0x222 <__bad_interrupt>
  8e:	00 00       	nop
  90:	c8 c0       	rjmp	.+400    	; 0x222 <__bad_interrupt>
  92:	00 00       	nop
  94:	c6 c0       	rjmp	.+396    	; 0x222 <__bad_interrupt>
  96:	00 00       	nop
  98:	c4 c0       	rjmp	.+392    	; 0x222 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	c2 c0       	rjmp	.+388    	; 0x222 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	c0 c0       	rjmp	.+384    	; 0x222 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	be c0       	rjmp	.+380    	; 0x222 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	bc c0       	rjmp	.+376    	; 0x222 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	ba c0       	rjmp	.+372    	; 0x222 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	b8 c0       	rjmp	.+368    	; 0x222 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	b6 c0       	rjmp	.+364    	; 0x222 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	b4 c0       	rjmp	.+360    	; 0x222 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	b2 c0       	rjmp	.+356    	; 0x222 <__bad_interrupt>
  be:	00 00       	nop
  c0:	b0 c0       	rjmp	.+352    	; 0x222 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	ae c0       	rjmp	.+348    	; 0x222 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	ac c0       	rjmp	.+344    	; 0x222 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	aa c0       	rjmp	.+340    	; 0x222 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	a8 c0       	rjmp	.+336    	; 0x222 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	a6 c0       	rjmp	.+332    	; 0x222 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	a4 c0       	rjmp	.+328    	; 0x222 <__bad_interrupt>
  da:	00 00       	nop
  dc:	a2 c0       	rjmp	.+324    	; 0x222 <__bad_interrupt>
  de:	00 00       	nop
  e0:	a0 c0       	rjmp	.+320    	; 0x222 <__bad_interrupt>
  e2:	00 00       	nop
  e4:	87 01       	movw	r16, r14
  e6:	8f 01       	movw	r16, r30
  e8:	8f 01       	movw	r16, r30
  ea:	8f 01       	movw	r16, r30
  ec:	89 01       	movw	r16, r18
  ee:	8f 01       	movw	r16, r30
  f0:	8b 01       	movw	r16, r22
  f2:	8d 01       	movw	r16, r26
  f4:	8f 01       	movw	r16, r30
  f6:	8f 01       	movw	r16, r30
  f8:	8f 01       	movw	r16, r30
  fa:	8f 01       	movw	r16, r30
  fc:	8f 01       	movw	r16, r30
  fe:	8f 01       	movw	r16, r30
 100:	8f 01       	movw	r16, r30
 102:	8f 01       	movw	r16, r30
 104:	8f 01       	movw	r16, r30
 106:	8f 01       	movw	r16, r30
 108:	8f 01       	movw	r16, r30
 10a:	8f 01       	movw	r16, r30
 10c:	8f 01       	movw	r16, r30
 10e:	8f 01       	movw	r16, r30
 110:	8f 01       	movw	r16, r30
 112:	8f 01       	movw	r16, r30
 114:	8f 01       	movw	r16, r30
 116:	8f 01       	movw	r16, r30
 118:	8f 01       	movw	r16, r30
 11a:	8f 01       	movw	r16, r30
 11c:	8f 01       	movw	r16, r30
 11e:	8f 01       	movw	r16, r30
 120:	8f 01       	movw	r16, r30
 122:	8f 01       	movw	r16, r30
 124:	8f 01       	movw	r16, r30
 126:	8f 01       	movw	r16, r30
 128:	8f 01       	movw	r16, r30
 12a:	8f 01       	movw	r16, r30
 12c:	8f 01       	movw	r16, r30
 12e:	8f 01       	movw	r16, r30
 130:	8f 01       	movw	r16, r30
 132:	8f 01       	movw	r16, r30
 134:	8f 01       	movw	r16, r30
 136:	8f 01       	movw	r16, r30
 138:	8f 01       	movw	r16, r30
 13a:	8f 01       	movw	r16, r30
 13c:	8f 01       	movw	r16, r30
 13e:	8f 01       	movw	r16, r30
 140:	8f 01       	movw	r16, r30
 142:	8f 01       	movw	r16, r30
 144:	8f 01       	movw	r16, r30
 146:	8f 01       	movw	r16, r30
 148:	8f 01       	movw	r16, r30
 14a:	8f 01       	movw	r16, r30
 14c:	8f 01       	movw	r16, r30
 14e:	8f 01       	movw	r16, r30
 150:	8f 01       	movw	r16, r30
 152:	8f 01       	movw	r16, r30
 154:	8f 01       	movw	r16, r30
 156:	8f 01       	movw	r16, r30
 158:	8f 01       	movw	r16, r30
 15a:	8f 01       	movw	r16, r30
 15c:	8f 01       	movw	r16, r30
 15e:	8f 01       	movw	r16, r30
 160:	8f 01       	movw	r16, r30
 162:	8f 01       	movw	r16, r30
 164:	7f 01       	movw	r14, r30
 166:	8f 01       	movw	r16, r30
 168:	8f 01       	movw	r16, r30
 16a:	8f 01       	movw	r16, r30
 16c:	81 01       	movw	r16, r2
 16e:	8f 01       	movw	r16, r30
 170:	83 01       	movw	r16, r6
 172:	85 01       	movw	r16, r10
 174:	8f 01       	movw	r16, r30
 176:	8f 01       	movw	r16, r30
 178:	8f 01       	movw	r16, r30
 17a:	8f 01       	movw	r16, r30
 17c:	8f 01       	movw	r16, r30
 17e:	8f 01       	movw	r16, r30
 180:	8f 01       	movw	r16, r30
 182:	8f 01       	movw	r16, r30
 184:	8f 01       	movw	r16, r30
 186:	8f 01       	movw	r16, r30
 188:	8f 01       	movw	r16, r30
 18a:	8f 01       	movw	r16, r30
 18c:	8f 01       	movw	r16, r30
 18e:	8f 01       	movw	r16, r30
 190:	8f 01       	movw	r16, r30
 192:	8f 01       	movw	r16, r30
 194:	8f 01       	movw	r16, r30
 196:	8f 01       	movw	r16, r30
 198:	8f 01       	movw	r16, r30
 19a:	8f 01       	movw	r16, r30
 19c:	8f 01       	movw	r16, r30
 19e:	8f 01       	movw	r16, r30
 1a0:	8f 01       	movw	r16, r30
 1a2:	8f 01       	movw	r16, r30
 1a4:	77 01       	movw	r14, r14
 1a6:	8f 01       	movw	r16, r30
 1a8:	8f 01       	movw	r16, r30
 1aa:	8f 01       	movw	r16, r30
 1ac:	79 01       	movw	r14, r18
 1ae:	8f 01       	movw	r16, r30
 1b0:	7b 01       	movw	r14, r22
 1b2:	7d 01       	movw	r14, r26
 1b4:	8f 01       	movw	r16, r30
 1b6:	8f 01       	movw	r16, r30
 1b8:	8f 01       	movw	r16, r30
 1ba:	8f 01       	movw	r16, r30
 1bc:	8f 01       	movw	r16, r30
 1be:	8f 01       	movw	r16, r30
 1c0:	8f 01       	movw	r16, r30
 1c2:	8f 01       	movw	r16, r30
 1c4:	71 01       	movw	r14, r2
 1c6:	8f 01       	movw	r16, r30
 1c8:	8f 01       	movw	r16, r30
 1ca:	8f 01       	movw	r16, r30
 1cc:	91 01       	movw	r18, r2
 1ce:	8f 01       	movw	r16, r30
 1d0:	73 01       	movw	r14, r6
 1d2:	75 01       	movw	r14, r10
 1d4:	f3 03       	fmuls	r23, r19
 1d6:	17 04       	cpc	r1, r7
 1d8:	2c 04       	cpc	r2, r12
 1da:	41 04       	cpc	r4, r1
 1dc:	56 04       	cpc	r5, r6
 1de:	68 04       	cpc	r6, r8
 1e0:	72 04       	cpc	r7, r2
 1e2:	7c 04       	cpc	r7, r12

000001e4 <__ctors_end>:
 1e4:	11 24       	eor	r1, r1
 1e6:	1f be       	out	0x3f, r1	; 63
 1e8:	cf ef       	ldi	r28, 0xFF	; 255
 1ea:	d1 e2       	ldi	r29, 0x21	; 33
 1ec:	de bf       	out	0x3e, r29	; 62
 1ee:	cd bf       	out	0x3d, r28	; 61
 1f0:	00 e0       	ldi	r16, 0x00	; 0
 1f2:	0c bf       	out	0x3c, r16	; 60

000001f4 <__do_copy_data>:
 1f4:	13 e0       	ldi	r17, 0x03	; 3
 1f6:	a0 e0       	ldi	r26, 0x00	; 0
 1f8:	b2 e0       	ldi	r27, 0x02	; 2
 1fa:	e2 e7       	ldi	r30, 0x72	; 114
 1fc:	ff e0       	ldi	r31, 0x0F	; 15
 1fe:	00 e0       	ldi	r16, 0x00	; 0
 200:	0b bf       	out	0x3b, r16	; 59
 202:	02 c0       	rjmp	.+4      	; 0x208 <__do_copy_data+0x14>
 204:	07 90       	elpm	r0, Z+
 206:	0d 92       	st	X+, r0
 208:	ac 34       	cpi	r26, 0x4C	; 76
 20a:	b1 07       	cpc	r27, r17
 20c:	d9 f7       	brne	.-10     	; 0x204 <__do_copy_data+0x10>

0000020e <__do_clear_bss>:
 20e:	23 e0       	ldi	r18, 0x03	; 3
 210:	ac e4       	ldi	r26, 0x4C	; 76
 212:	b3 e0       	ldi	r27, 0x03	; 3
 214:	01 c0       	rjmp	.+2      	; 0x218 <.do_clear_bss_start>

00000216 <.do_clear_bss_loop>:
 216:	1d 92       	st	X+, r1

00000218 <.do_clear_bss_start>:
 218:	aa 35       	cpi	r26, 0x5A	; 90
 21a:	b2 07       	cpc	r27, r18
 21c:	e1 f7       	brne	.-8      	; 0x216 <.do_clear_bss_loop>
 21e:	3a d6       	rcall	.+3188   	; 0xe94 <main>
 220:	a6 c6       	rjmp	.+3404   	; 0xf6e <_exit>

00000222 <__bad_interrupt>:
 222:	ee ce       	rjmp	.-548    	; 0x0 <__vectors>

00000224 <keypad_ScanKey>:
static uint8_t keypad_ScanKey()
{

	uint8_t var_keyScanCode_u8 = 0xEF,i, var_keyPress_u8;

	for(i=0;i<0x04;i++)                // Scan All the 4-Rows for key press
 224:	20 e0       	ldi	r18, 0x00	; 0
        4.Return the ScanCode(Combination of ROW & COL) for decoding the key.
 ***************************************************************************************************/
static uint8_t keypad_ScanKey()
{

	uint8_t var_keyScanCode_u8 = 0xEF,i, var_keyPress_u8;
 226:	9f ee       	ldi	r25, 0xEF	; 239

	for(i=0;i<0x04;i++)                // Scan All the 4-Rows for key press
 228:	10 c0       	rjmp	.+32     	; 0x24a <keypad_ScanKey+0x26>
	{
		M_ROW=var_keyScanCode_u8;        // Select 1-Row at a time for Scanning the Key
 22a:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <__TEXT_REGION_LENGTH__+0x7c0108>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 22e:	e9 ef       	ldi	r30, 0xF9	; 249
 230:	f0 e0       	ldi	r31, 0x00	; 0
 232:	31 97       	sbiw	r30, 0x01	; 1
 234:	f1 f7       	brne	.-4      	; 0x232 <keypad_ScanKey+0xe>
 236:	00 c0       	rjmp	.+0      	; 0x238 <keypad_ScanKey+0x14>
 238:	00 00       	nop
		DELAY_ms(1);
		var_keyPress_u8=M_COL & 0x0F;    // Read the Column, for key press
 23a:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x7c0106>
 23e:	8f 70       	andi	r24, 0x0F	; 15

		if(var_keyPress_u8!=0x0F)        // If the KEY press is detected for the selected
 240:	8f 30       	cpi	r24, 0x0F	; 15
 242:	29 f4       	brne	.+10     	; 0x24e <keypad_ScanKey+0x2a>
			break;                     // ROW then stop Scanning,

		var_keyScanCode_u8=((var_keyScanCode_u8<<1)+0x01); // Rotate the ScanKey to SCAN the remaining Rows
 244:	99 0f       	add	r25, r25
 246:	9f 5f       	subi	r25, 0xFF	; 255
static uint8_t keypad_ScanKey()
{

	uint8_t var_keyScanCode_u8 = 0xEF,i, var_keyPress_u8;

	for(i=0;i<0x04;i++)                // Scan All the 4-Rows for key press
 248:	2f 5f       	subi	r18, 0xFF	; 255
 24a:	24 30       	cpi	r18, 0x04	; 4
 24c:	70 f3       	brcs	.-36     	; 0x22a <keypad_ScanKey+0x6>
		if(var_keyPress_u8!=0x0F)        // If the KEY press is detected for the selected
			break;                     // ROW then stop Scanning,

		var_keyScanCode_u8=((var_keyScanCode_u8<<1)+0x01); // Rotate the ScanKey to SCAN the remaining Rows
	}
	var_keyPress_u8 = var_keyPress_u8 + (var_keyScanCode_u8 & 0xf0); // Return the row and COL status to decode the key
 24e:	90 7f       	andi	r25, 0xF0	; 240
	return(var_keyPress_u8);
}
 250:	89 0f       	add	r24, r25
 252:	08 95       	ret

00000254 <KEYPAD_Init>:
        1.ROW lines are configured as Output.
        2.Column Lines are configured as Input.
 ***************************************************************************************************/
void KEYPAD_Init()
{
	M_RowColDirection= C_RowOutputColInput_U8; // Configure Row lines as O/P and Column lines as I/P
 254:	80 ef       	ldi	r24, 0xF0	; 240
 256:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x7c0107>
 25a:	08 95       	ret

0000025c <KEYPAD_WaitForKeyRelease>:
	uint8_t key;
	do
	{
		do
		{
			M_ROW=0x0F;           // Pull the ROW lines to low and Column lines high.
 25c:	8f e0       	ldi	r24, 0x0F	; 15
 25e:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x7c0108>
			key=M_COL & 0x0F;     // Read the Columns, to check the key press
 262:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x7c0106>
 266:	8f 70       	andi	r24, 0x0F	; 15
		}while(key!=0x0F);
 268:	8f 30       	cpi	r24, 0x0F	; 15
 26a:	c1 f7       	brne	.-16     	; 0x25c <KEYPAD_WaitForKeyRelease>
 26c:	89 ef       	ldi	r24, 0xF9	; 249
 26e:	90 e0       	ldi	r25, 0x00	; 0
 270:	01 97       	sbiw	r24, 0x01	; 1
 272:	f1 f7       	brne	.-4      	; 0x270 <KEYPAD_WaitForKeyRelease+0x14>
 274:	00 c0       	rjmp	.+0      	; 0x276 <KEYPAD_WaitForKeyRelease+0x1a>
 276:	00 00       	nop

		DELAY_ms(1);

		M_ROW=0x0F;           // Pull the ROW lines to low and Column lines high.
 278:	8f e0       	ldi	r24, 0x0F	; 15
 27a:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x7c0108>
		key=M_COL & 0x0F;     // Read the Columns, to check the key press
 27e:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x7c0106>
 282:	8f 70       	andi	r24, 0x0F	; 15
	}while(key!=0x0F);   // Wait till the Key is released,
 284:	8f 30       	cpi	r24, 0x0F	; 15
 286:	51 f7       	brne	.-44     	; 0x25c <KEYPAD_WaitForKeyRelease>
	                     // If no Key is pressed, Column lines will be High(0x0F)
}
 288:	08 95       	ret

0000028a <KEYPAD_WaitForKeyPress>:
	uint8_t var_keyPress_u8;
	do
	{
		do
		{
			M_ROW=0x0F;		  // Pull the ROW lines to low and Column lines high.
 28a:	8f e0       	ldi	r24, 0x0F	; 15
 28c:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x7c0108>
			var_keyPress_u8=M_COL & 0x0F;	  // Read the Columns, to check the key press
 290:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x7c0106>
 294:	8f 70       	andi	r24, 0x0F	; 15
		}while(var_keyPress_u8==0x0F); // Wait till the Key is pressed,
 296:	8f 30       	cpi	r24, 0x0F	; 15
 298:	c1 f3       	breq	.-16     	; 0x28a <KEYPAD_WaitForKeyPress>
 29a:	89 ef       	ldi	r24, 0xF9	; 249
 29c:	90 e0       	ldi	r25, 0x00	; 0
 29e:	01 97       	sbiw	r24, 0x01	; 1
 2a0:	f1 f7       	brne	.-4      	; 0x29e <KEYPAD_WaitForKeyPress+0x14>
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <KEYPAD_WaitForKeyPress+0x1a>
 2a4:	00 00       	nop
		// if a Key is pressed the corresponding Column line go low

		DELAY_ms(1);		  // Wait for some time(debounce Time);

		M_ROW=0x0F;		  // After debounce time, perform the above operation
 2a6:	8f e0       	ldi	r24, 0x0F	; 15
 2a8:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x7c0108>
		var_keyPress_u8=M_COL & 0x0F;	  // to ensure the Key press.
 2ac:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x7c0106>
 2b0:	8f 70       	andi	r24, 0x0F	; 15

	}while(var_keyPress_u8==0x0F);
 2b2:	8f 30       	cpi	r24, 0x0F	; 15
 2b4:	51 f3       	breq	.-44     	; 0x28a <KEYPAD_WaitForKeyPress>
}
 2b6:	08 95       	ret

000002b8 <KEYPAD_GetKey>:
 ***************************************************************************************************/
uint8_t KEYPAD_GetKey()
{
	uint8_t var_keyPress_u8;

	KEYPAD_WaitForKeyRelease();    // Wait for the previous key release
 2b8:	d1 df       	rcall	.-94     	; 0x25c <KEYPAD_WaitForKeyRelease>
 2ba:	89 ef       	ldi	r24, 0xF9	; 249
 2bc:	90 e0       	ldi	r25, 0x00	; 0
 2be:	01 97       	sbiw	r24, 0x01	; 1
 2c0:	f1 f7       	brne	.-4      	; 0x2be <KEYPAD_GetKey+0x6>
 2c2:	00 c0       	rjmp	.+0      	; 0x2c4 <KEYPAD_GetKey+0xc>
	DELAY_ms(1);

	KEYPAD_WaitForKeyPress();      // Wait for the new key press
 2c4:	00 00       	nop
	var_keyPress_u8 = keypad_ScanKey();        // Scan for the key pressed.
 2c6:	e1 df       	rcall	.-62     	; 0x28a <KEYPAD_WaitForKeyPress>
 2c8:	ad df       	rcall	.-166    	; 0x224 <keypad_ScanKey>

	switch(var_keyPress_u8)                       // Decode the key
 2ca:	90 e0       	ldi	r25, 0x00	; 0
 2cc:	fc 01       	movw	r30, r24
 2ce:	e7 57       	subi	r30, 0x77	; 119
 2d0:	f1 09       	sbc	r31, r1
 2d2:	e8 37       	cpi	r30, 0x78	; 120
 2d4:	f1 05       	cpc	r31, r1
 2d6:	18 f5       	brcc	.+70     	; 0x31e <KEYPAD_GetKey+0x66>
 2d8:	88 27       	eor	r24, r24
 2da:	ee 58       	subi	r30, 0x8E	; 142
 2dc:	ff 4f       	sbci	r31, 0xFF	; 255
 2de:	8f 4f       	sbci	r24, 0xFF	; 255
 2e0:	0b c6       	rjmp	.+3094   	; 0xef8 <__tablejump2__>
	{
	case 0xe7: var_keyPress_u8='*'; break; 
 2e2:	8a e2       	ldi	r24, 0x2A	; 42
 2e4:	08 95       	ret
	case 0xeb: var_keyPress_u8='7'; break; 
	case 0xed: var_keyPress_u8='4'; break; 
 2e6:	84 e3       	ldi	r24, 0x34	; 52
 2e8:	08 95       	ret
	case 0xee: var_keyPress_u8='1'; break; 
 2ea:	81 e3       	ldi	r24, 0x31	; 49
 2ec:	08 95       	ret
	case 0xd7: var_keyPress_u8='0'; break; 
 2ee:	80 e3       	ldi	r24, 0x30	; 48
 2f0:	08 95       	ret
	case 0xdb: var_keyPress_u8='8'; break; 
 2f2:	88 e3       	ldi	r24, 0x38	; 56
 2f4:	08 95       	ret
	case 0xdd: var_keyPress_u8='5'; break; 
 2f6:	85 e3       	ldi	r24, 0x35	; 53
 2f8:	08 95       	ret
	case 0xde: var_keyPress_u8='2'; break; 
 2fa:	82 e3       	ldi	r24, 0x32	; 50
 2fc:	08 95       	ret
	case 0xb7: var_keyPress_u8='#'; break; 
 2fe:	83 e2       	ldi	r24, 0x23	; 35
 300:	08 95       	ret
	case 0xbb: var_keyPress_u8='9'; break; 
 302:	89 e3       	ldi	r24, 0x39	; 57
 304:	08 95       	ret
	case 0xbd: var_keyPress_u8='6'; break; 
 306:	86 e3       	ldi	r24, 0x36	; 54
 308:	08 95       	ret
	case 0xbe: var_keyPress_u8='3'; break; 
 30a:	83 e3       	ldi	r24, 0x33	; 51
 30c:	08 95       	ret
	case 0x77: var_keyPress_u8='D'; break;  
 30e:	84 e4       	ldi	r24, 0x44	; 68
 310:	08 95       	ret
	case 0x7b: var_keyPress_u8='C'; break;  
 312:	83 e4       	ldi	r24, 0x43	; 67
 314:	08 95       	ret
	case 0x7d: var_keyPress_u8='B'; break;  
 316:	82 e4       	ldi	r24, 0x42	; 66
 318:	08 95       	ret
	case 0x7e: var_keyPress_u8='A'; break;  
 31a:	81 e4       	ldi	r24, 0x41	; 65
 31c:	08 95       	ret
	default  : var_keyPress_u8='z'; break;
 31e:	8a e7       	ldi	r24, 0x7A	; 122
 320:	08 95       	ret
	var_keyPress_u8 = keypad_ScanKey();        // Scan for the key pressed.

	switch(var_keyPress_u8)                       // Decode the key
	{
	case 0xe7: var_keyPress_u8='*'; break; 
	case 0xeb: var_keyPress_u8='7'; break; 
 322:	87 e3       	ldi	r24, 0x37	; 55
	case 0x7d: var_keyPress_u8='B'; break;  
	case 0x7e: var_keyPress_u8='A'; break;  
	default  : var_keyPress_u8='z'; break;
	}
	return(var_keyPress_u8);                      // Return the key
}
 324:	08 95       	ret

00000326 <toggle_e>:

    while ( (c = pgm_read_byte(progmem_s++)) ) {
        lcd_putc(c);
    }

}/* lcd_puts_p */
 326:	85 b1       	in	r24, 0x05	; 5
 328:	80 62       	ori	r24, 0x20	; 32
 32a:	85 b9       	out	0x05, r24	; 5
 32c:	00 00       	nop
 32e:	85 b1       	in	r24, 0x05	; 5
 330:	8f 7d       	andi	r24, 0xDF	; 223
 332:	85 b9       	out	0x05, r24	; 5
 334:	08 95       	ret

00000336 <lcd_write>:
 336:	cf 93       	push	r28
 338:	c8 2f       	mov	r28, r24
 33a:	66 23       	and	r22, r22
 33c:	31 f0       	breq	.+12     	; 0x34a <lcd_write+0x14>
 33e:	e2 e0       	ldi	r30, 0x02	; 2
 340:	f1 e0       	ldi	r31, 0x01	; 1
 342:	80 81       	ld	r24, Z
 344:	80 64       	ori	r24, 0x40	; 64
 346:	80 83       	st	Z, r24
 348:	05 c0       	rjmp	.+10     	; 0x354 <lcd_write+0x1e>
 34a:	e2 e0       	ldi	r30, 0x02	; 2
 34c:	f1 e0       	ldi	r31, 0x01	; 1
 34e:	80 81       	ld	r24, Z
 350:	8f 7b       	andi	r24, 0xBF	; 191
 352:	80 83       	st	Z, r24
 354:	85 b1       	in	r24, 0x05	; 5
 356:	8f 7e       	andi	r24, 0xEF	; 239
 358:	85 b9       	out	0x05, r24	; 5
 35a:	8d b1       	in	r24, 0x0d	; 13
 35c:	80 62       	ori	r24, 0x20	; 32
 35e:	8d b9       	out	0x0d, r24	; 13
 360:	83 b3       	in	r24, 0x13	; 19
 362:	80 62       	ori	r24, 0x20	; 32
 364:	83 bb       	out	0x13, r24	; 19
 366:	8d b1       	in	r24, 0x0d	; 13
 368:	88 60       	ori	r24, 0x08	; 8
 36a:	8d b9       	out	0x0d, r24	; 13
 36c:	e1 e0       	ldi	r30, 0x01	; 1
 36e:	f1 e0       	ldi	r31, 0x01	; 1
 370:	80 81       	ld	r24, Z
 372:	88 60       	ori	r24, 0x08	; 8
 374:	80 83       	st	Z, r24
 376:	e2 e0       	ldi	r30, 0x02	; 2
 378:	f1 e0       	ldi	r31, 0x01	; 1
 37a:	80 81       	ld	r24, Z
 37c:	87 7f       	andi	r24, 0xF7	; 247
 37e:	80 83       	st	Z, r24
 380:	8e b1       	in	r24, 0x0e	; 14
 382:	87 7f       	andi	r24, 0xF7	; 247
 384:	8e b9       	out	0x0e, r24	; 14
 386:	84 b3       	in	r24, 0x14	; 20
 388:	8f 7d       	andi	r24, 0xDF	; 223
 38a:	84 bb       	out	0x14, r24	; 20
 38c:	8e b1       	in	r24, 0x0e	; 14
 38e:	8f 7d       	andi	r24, 0xDF	; 223
 390:	8e b9       	out	0x0e, r24	; 14
 392:	cc 23       	and	r28, r28
 394:	1c f4       	brge	.+6      	; 0x39c <lcd_write+0x66>
 396:	80 81       	ld	r24, Z
 398:	88 60       	ori	r24, 0x08	; 8
 39a:	80 83       	st	Z, r24
 39c:	c6 ff       	sbrs	r28, 6
 39e:	03 c0       	rjmp	.+6      	; 0x3a6 <lcd_write+0x70>
 3a0:	8e b1       	in	r24, 0x0e	; 14
 3a2:	88 60       	ori	r24, 0x08	; 8
 3a4:	8e b9       	out	0x0e, r24	; 14
 3a6:	c5 ff       	sbrs	r28, 5
 3a8:	03 c0       	rjmp	.+6      	; 0x3b0 <lcd_write+0x7a>
 3aa:	84 b3       	in	r24, 0x14	; 20
 3ac:	80 62       	ori	r24, 0x20	; 32
 3ae:	84 bb       	out	0x14, r24	; 20
 3b0:	c4 ff       	sbrs	r28, 4
 3b2:	03 c0       	rjmp	.+6      	; 0x3ba <lcd_write+0x84>
 3b4:	8e b1       	in	r24, 0x0e	; 14
 3b6:	80 62       	ori	r24, 0x20	; 32
 3b8:	8e b9       	out	0x0e, r24	; 14
 3ba:	b5 df       	rcall	.-150    	; 0x326 <toggle_e>
 3bc:	e2 e0       	ldi	r30, 0x02	; 2
 3be:	f1 e0       	ldi	r31, 0x01	; 1
 3c0:	80 81       	ld	r24, Z
 3c2:	87 7f       	andi	r24, 0xF7	; 247
 3c4:	80 83       	st	Z, r24
 3c6:	8e b1       	in	r24, 0x0e	; 14
 3c8:	87 7f       	andi	r24, 0xF7	; 247
 3ca:	8e b9       	out	0x0e, r24	; 14
 3cc:	84 b3       	in	r24, 0x14	; 20
 3ce:	8f 7d       	andi	r24, 0xDF	; 223
 3d0:	84 bb       	out	0x14, r24	; 20
 3d2:	8e b1       	in	r24, 0x0e	; 14
 3d4:	8f 7d       	andi	r24, 0xDF	; 223
 3d6:	8e b9       	out	0x0e, r24	; 14
 3d8:	c3 ff       	sbrs	r28, 3
 3da:	03 c0       	rjmp	.+6      	; 0x3e2 <lcd_write+0xac>
 3dc:	80 81       	ld	r24, Z
 3de:	88 60       	ori	r24, 0x08	; 8
 3e0:	80 83       	st	Z, r24
 3e2:	c2 ff       	sbrs	r28, 2
 3e4:	03 c0       	rjmp	.+6      	; 0x3ec <lcd_write+0xb6>
 3e6:	8e b1       	in	r24, 0x0e	; 14
 3e8:	88 60       	ori	r24, 0x08	; 8
 3ea:	8e b9       	out	0x0e, r24	; 14
 3ec:	c1 ff       	sbrs	r28, 1
 3ee:	03 c0       	rjmp	.+6      	; 0x3f6 <lcd_write+0xc0>
 3f0:	84 b3       	in	r24, 0x14	; 20
 3f2:	80 62       	ori	r24, 0x20	; 32
 3f4:	84 bb       	out	0x14, r24	; 20
 3f6:	c0 ff       	sbrs	r28, 0
 3f8:	03 c0       	rjmp	.+6      	; 0x400 <__LOCK_REGION_LENGTH__>
 3fa:	8e b1       	in	r24, 0x0e	; 14
 3fc:	80 62       	ori	r24, 0x20	; 32
 3fe:	8e b9       	out	0x0e, r24	; 14
 400:	92 df       	rcall	.-220    	; 0x326 <toggle_e>
 402:	8e b1       	in	r24, 0x0e	; 14
 404:	80 62       	ori	r24, 0x20	; 32
 406:	8e b9       	out	0x0e, r24	; 14
 408:	84 b3       	in	r24, 0x14	; 20
 40a:	80 62       	ori	r24, 0x20	; 32
 40c:	84 bb       	out	0x14, r24	; 20
 40e:	8e b1       	in	r24, 0x0e	; 14
 410:	88 60       	ori	r24, 0x08	; 8
 412:	8e b9       	out	0x0e, r24	; 14
 414:	e2 e0       	ldi	r30, 0x02	; 2
 416:	f1 e0       	ldi	r31, 0x01	; 1
 418:	80 81       	ld	r24, Z
 41a:	88 60       	ori	r24, 0x08	; 8
 41c:	80 83       	st	Z, r24
 41e:	cf 91       	pop	r28
 420:	08 95       	ret

00000422 <lcd_read>:
 422:	88 23       	and	r24, r24
 424:	31 f0       	breq	.+12     	; 0x432 <lcd_read+0x10>
 426:	e2 e0       	ldi	r30, 0x02	; 2
 428:	f1 e0       	ldi	r31, 0x01	; 1
 42a:	80 81       	ld	r24, Z
 42c:	80 64       	ori	r24, 0x40	; 64
 42e:	80 83       	st	Z, r24
 430:	05 c0       	rjmp	.+10     	; 0x43c <lcd_read+0x1a>
 432:	e2 e0       	ldi	r30, 0x02	; 2
 434:	f1 e0       	ldi	r31, 0x01	; 1
 436:	80 81       	ld	r24, Z
 438:	8f 7b       	andi	r24, 0xBF	; 191
 43a:	80 83       	st	Z, r24
 43c:	85 b1       	in	r24, 0x05	; 5
 43e:	80 61       	ori	r24, 0x10	; 16
 440:	85 b9       	out	0x05, r24	; 5
 442:	8d b1       	in	r24, 0x0d	; 13
 444:	8f 7d       	andi	r24, 0xDF	; 223
 446:	8d b9       	out	0x0d, r24	; 13
 448:	83 b3       	in	r24, 0x13	; 19
 44a:	8f 7d       	andi	r24, 0xDF	; 223
 44c:	83 bb       	out	0x13, r24	; 19
 44e:	8d b1       	in	r24, 0x0d	; 13
 450:	87 7f       	andi	r24, 0xF7	; 247
 452:	8d b9       	out	0x0d, r24	; 13
 454:	e1 e0       	ldi	r30, 0x01	; 1
 456:	f1 e0       	ldi	r31, 0x01	; 1
 458:	80 81       	ld	r24, Z
 45a:	87 7f       	andi	r24, 0xF7	; 247
 45c:	80 83       	st	Z, r24
 45e:	85 b1       	in	r24, 0x05	; 5
 460:	80 62       	ori	r24, 0x20	; 32
 462:	85 b9       	out	0x05, r24	; 5
 464:	00 00       	nop
 466:	65 99       	sbic	0x0c, 5	; 12
 468:	02 c0       	rjmp	.+4      	; 0x46e <lcd_read+0x4c>
 46a:	80 e0       	ldi	r24, 0x00	; 0
 46c:	01 c0       	rjmp	.+2      	; 0x470 <lcd_read+0x4e>
 46e:	80 e1       	ldi	r24, 0x10	; 16
 470:	95 99       	sbic	0x12, 5	; 18
 472:	80 62       	ori	r24, 0x20	; 32
 474:	63 99       	sbic	0x0c, 3	; 12
 476:	80 64       	ori	r24, 0x40	; 64
 478:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__TEXT_REGION_LENGTH__+0x7c0100>
 47c:	93 fd       	sbrc	r25, 3
 47e:	80 68       	ori	r24, 0x80	; 128
 480:	95 b1       	in	r25, 0x05	; 5
 482:	9f 7d       	andi	r25, 0xDF	; 223
 484:	95 b9       	out	0x05, r25	; 5
 486:	00 00       	nop
 488:	95 b1       	in	r25, 0x05	; 5
 48a:	90 62       	ori	r25, 0x20	; 32
 48c:	95 b9       	out	0x05, r25	; 5
 48e:	00 00       	nop
 490:	65 99       	sbic	0x0c, 5	; 12
 492:	81 60       	ori	r24, 0x01	; 1
 494:	95 99       	sbic	0x12, 5	; 18
 496:	82 60       	ori	r24, 0x02	; 2
 498:	63 99       	sbic	0x0c, 3	; 12
 49a:	84 60       	ori	r24, 0x04	; 4
 49c:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__TEXT_REGION_LENGTH__+0x7c0100>
 4a0:	93 fd       	sbrc	r25, 3
 4a2:	88 60       	ori	r24, 0x08	; 8
 4a4:	95 b1       	in	r25, 0x05	; 5
 4a6:	9f 7d       	andi	r25, 0xDF	; 223
 4a8:	95 b9       	out	0x05, r25	; 5
 4aa:	08 95       	ret

000004ac <lcd_waitbusy>:
 4ac:	80 e0       	ldi	r24, 0x00	; 0
 4ae:	b9 df       	rcall	.-142    	; 0x422 <lcd_read>
 4b0:	88 23       	and	r24, r24
 4b2:	e4 f3       	brlt	.-8      	; 0x4ac <lcd_waitbusy>
 4b4:	00 c0       	rjmp	.+0      	; 0x4b6 <lcd_waitbusy+0xa>
 4b6:	00 c0       	rjmp	.+0      	; 0x4b8 <lcd_waitbusy+0xc>
 4b8:	80 e0       	ldi	r24, 0x00	; 0
 4ba:	b3 cf       	rjmp	.-154    	; 0x422 <lcd_read>
 4bc:	08 95       	ret

000004be <lcd_command>:
 4be:	cf 93       	push	r28
 4c0:	c8 2f       	mov	r28, r24
 4c2:	f4 df       	rcall	.-24     	; 0x4ac <lcd_waitbusy>
 4c4:	60 e0       	ldi	r22, 0x00	; 0
 4c6:	8c 2f       	mov	r24, r28
 4c8:	36 df       	rcall	.-404    	; 0x336 <lcd_write>
 4ca:	cf 91       	pop	r28
 4cc:	08 95       	ret

000004ce <lcd_gotoxy>:
 4ce:	61 11       	cpse	r22, r1
 4d0:	03 c0       	rjmp	.+6      	; 0x4d8 <lcd_gotoxy+0xa>
 4d2:	80 58       	subi	r24, 0x80	; 128
 4d4:	f4 cf       	rjmp	.-24     	; 0x4be <lcd_command>
 4d6:	08 95       	ret
 4d8:	80 54       	subi	r24, 0x40	; 64
 4da:	f1 cf       	rjmp	.-30     	; 0x4be <lcd_command>
 4dc:	08 95       	ret

000004de <lcd_clrscr>:
 4de:	81 e0       	ldi	r24, 0x01	; 1
 4e0:	ee cf       	rjmp	.-36     	; 0x4be <lcd_command>
 4e2:	08 95       	ret

000004e4 <lcd_putc>:
 4e4:	cf 93       	push	r28
 4e6:	c8 2f       	mov	r28, r24
 4e8:	e1 df       	rcall	.-62     	; 0x4ac <lcd_waitbusy>
 4ea:	ca 30       	cpi	r28, 0x0A	; 10
 4ec:	41 f4       	brne	.+16     	; 0x4fe <lcd_putc+0x1a>
 4ee:	80 34       	cpi	r24, 0x40	; 64
 4f0:	10 f4       	brcc	.+4      	; 0x4f6 <lcd_putc+0x12>
 4f2:	80 e4       	ldi	r24, 0x40	; 64
 4f4:	01 c0       	rjmp	.+2      	; 0x4f8 <lcd_putc+0x14>
 4f6:	80 e0       	ldi	r24, 0x00	; 0
 4f8:	80 58       	subi	r24, 0x80	; 128
 4fa:	e1 df       	rcall	.-62     	; 0x4be <lcd_command>
 4fc:	03 c0       	rjmp	.+6      	; 0x504 <lcd_putc+0x20>
 4fe:	61 e0       	ldi	r22, 0x01	; 1
 500:	8c 2f       	mov	r24, r28
 502:	19 df       	rcall	.-462    	; 0x336 <lcd_write>
 504:	cf 91       	pop	r28
 506:	08 95       	ret

00000508 <lcd_puts>:
 508:	cf 93       	push	r28
 50a:	df 93       	push	r29
 50c:	fc 01       	movw	r30, r24
 50e:	02 c0       	rjmp	.+4      	; 0x514 <lcd_puts+0xc>
 510:	e9 df       	rcall	.-46     	; 0x4e4 <lcd_putc>
 512:	fe 01       	movw	r30, r28
 514:	ef 01       	movw	r28, r30
 516:	21 96       	adiw	r28, 0x01	; 1
 518:	80 81       	ld	r24, Z
 51a:	81 11       	cpse	r24, r1
 51c:	f9 cf       	rjmp	.-14     	; 0x510 <lcd_puts+0x8>
 51e:	df 91       	pop	r29
 520:	cf 91       	pop	r28
 522:	08 95       	ret

00000524 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
 524:	cf 93       	push	r28
 526:	c8 2f       	mov	r28, r24
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    }
    else
    {
        /* configure all port bits as output (LCD data and control lines on different ports */
        DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
 528:	e1 e0       	ldi	r30, 0x01	; 1
 52a:	f1 e0       	ldi	r31, 0x01	; 1
 52c:	80 81       	ld	r24, Z
 52e:	80 64       	ori	r24, 0x40	; 64
 530:	80 83       	st	Z, r24
        DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
 532:	84 b1       	in	r24, 0x04	; 4
 534:	80 61       	ori	r24, 0x10	; 16
 536:	84 b9       	out	0x04, r24	; 4
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
 538:	84 b1       	in	r24, 0x04	; 4
 53a:	80 62       	ori	r24, 0x20	; 32
 53c:	84 b9       	out	0x04, r24	; 4
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
 53e:	8d b1       	in	r24, 0x0d	; 13
 540:	80 62       	ori	r24, 0x20	; 32
 542:	8d b9       	out	0x0d, r24	; 13
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
 544:	83 b3       	in	r24, 0x13	; 19
 546:	80 62       	ori	r24, 0x20	; 32
 548:	83 bb       	out	0x13, r24	; 19
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
 54a:	8d b1       	in	r24, 0x0d	; 13
 54c:	88 60       	ori	r24, 0x08	; 8
 54e:	8d b9       	out	0x0d, r24	; 13
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
 550:	80 81       	ld	r24, Z
 552:	88 60       	ori	r24, 0x08	; 8
 554:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 556:	8f e9       	ldi	r24, 0x9F	; 159
 558:	9f e0       	ldi	r25, 0x0F	; 15
 55a:	01 97       	sbiw	r24, 0x01	; 1
 55c:	f1 f7       	brne	.-4      	; 0x55a <lcd_init+0x36>
 55e:	00 c0       	rjmp	.+0      	; 0x560 <lcd_init+0x3c>
 560:	00 00       	nop
    }
    delay(LCD_DELAY_BOOTUP);             /* wait 16ms or more after power-on       */
    
    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);    // LCD_FUNCTION>>4;
 562:	84 b3       	in	r24, 0x14	; 20
 564:	80 62       	ori	r24, 0x20	; 32
 566:	84 bb       	out	0x14, r24	; 20
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);    // LCD_FUNCTION_8BIT>>4;
 568:	8e b1       	in	r24, 0x0e	; 14
 56a:	80 62       	ori	r24, 0x20	; 32
 56c:	8e b9       	out	0x0e, r24	; 14
    lcd_e_toggle();
 56e:	db de       	rcall	.-586    	; 0x326 <toggle_e>
 570:	81 ee       	ldi	r24, 0xE1	; 225
 572:	94 e0       	ldi	r25, 0x04	; 4
 574:	01 97       	sbiw	r24, 0x01	; 1
 576:	f1 f7       	brne	.-4      	; 0x574 <lcd_init+0x50>
 578:	00 c0       	rjmp	.+0      	; 0x57a <lcd_init+0x56>
    delay(LCD_DELAY_INIT);               /* delay, busy flag can't be checked here */
   
    /* repeat last command */ 
    lcd_e_toggle();      
 57a:	00 00       	nop
 57c:	d4 de       	rcall	.-600    	; 0x326 <toggle_e>
 57e:	95 e1       	ldi	r25, 0x15	; 21
 580:	9a 95       	dec	r25
 582:	f1 f7       	brne	.-4      	; 0x580 <lcd_init+0x5c>
    delay(LCD_DELAY_INIT_REP);           /* delay, busy flag can't be checked here */
    
    /* repeat last command a third time */
    lcd_e_toggle();      
 584:	00 00       	nop
 586:	cf de       	rcall	.-610    	; 0x326 <toggle_e>
 588:	85 e1       	ldi	r24, 0x15	; 21
 58a:	8a 95       	dec	r24
 58c:	f1 f7       	brne	.-4      	; 0x58a <lcd_init+0x66>
 58e:	00 00       	nop
    delay(LCD_DELAY_INIT_REP);           /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
 590:	8e b1       	in	r24, 0x0e	; 14
 592:	8f 7d       	andi	r24, 0xDF	; 223
    lcd_e_toggle();
 594:	8e b9       	out	0x0e, r24	; 14
 596:	c7 de       	rcall	.-626    	; 0x326 <toggle_e>
 598:	95 e1       	ldi	r25, 0x15	; 21
 59a:	9a 95       	dec	r25
 59c:	f1 f7       	brne	.-4      	; 0x59a <lcd_init+0x76>
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
	lcd_command(KS0073_4LINES_MODE);
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
#else
    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
 59e:	00 00       	nop
 5a0:	88 e2       	ldi	r24, 0x28	; 40
#endif
    lcd_command(LCD_DISP_OFF);              /* display off                  */
 5a2:	8d df       	rcall	.-230    	; 0x4be <lcd_command>
 5a4:	88 e0       	ldi	r24, 0x08	; 8
    lcd_clrscr();                           /* display clear                */ 
 5a6:	8b df       	rcall	.-234    	; 0x4be <lcd_command>
 5a8:	9a df       	rcall	.-204    	; 0x4de <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
 5aa:	86 e0       	ldi	r24, 0x06	; 6
 5ac:	88 df       	rcall	.-240    	; 0x4be <lcd_command>
 5ae:	8c 2f       	mov	r24, r28
    lcd_command(dispAttr);                  /* display/cursor control       */
 5b0:	86 df       	rcall	.-244    	; 0x4be <lcd_command>
 5b2:	cf 91       	pop	r28
 5b4:	08 95       	ret

000005b6 <is_emergency_button_pressed>:
uint8_t is_emergency_button_pressed(void);

// Simple function to check if emergency button is pressed (returns 1 if pressed)
uint8_t is_emergency_button_pressed(void) {
    // With external pull-up, button reads LOW when pressed
    return ((EMERGENCY_BTN_PIN & (1 << EMERGENCY_BTN_BIT)) == 0) ? 1 : 0;
 5b6:	83 b1       	in	r24, 0x03	; 3
 5b8:	82 95       	swap	r24
 5ba:	86 95       	lsr	r24
 5bc:	86 95       	lsr	r24
 5be:	83 70       	andi	r24, 0x03	; 3
 5c0:	91 e0       	ldi	r25, 0x01	; 1
 5c2:	89 27       	eor	r24, r25
}
 5c4:	81 70       	andi	r24, 0x01	; 1
 5c6:	08 95       	ret

000005c8 <TWI_init_master>:

// Initialize TWI/I2C as master
void TWI_init_master(void) {
    // Set SCL frequency to 100kHz
    TWSR = 0x00;  // Prescaler value = 1
 5c8:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7c00b9>
    TWBR = 0x48;  // SCL frequency = CPU_CLOCK/(16 + 2*TWBR*Prescaler)
 5cc:	88 e4       	ldi	r24, 0x48	; 72
 5ce:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7c00b8>
    
    // Enable TWI
    TWCR = (1 << TWEN);
 5d2:	84 e0       	ldi	r24, 0x04	; 4
 5d4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
 5d8:	08 95       	ret

000005da <TWI_start>:
}

// Send start condition
void TWI_start(void) {
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
 5da:	84 ea       	ldi	r24, 0xA4	; 164
 5dc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    while (!(TWCR & (1 << TWINT)));  // Wait for TWINT flag
 5e0:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
 5e4:	88 23       	and	r24, r24
 5e6:	e4 f7       	brge	.-8      	; 0x5e0 <TWI_start+0x6>
}
 5e8:	08 95       	ret

000005ea <TWI_stop>:

// Send stop condition
void TWI_stop(void) {
    TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
 5ea:	84 e9       	ldi	r24, 0x94	; 148
 5ec:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 5f0:	8f e9       	ldi	r24, 0x9F	; 159
 5f2:	9f e0       	ldi	r25, 0x0F	; 15
 5f4:	01 97       	sbiw	r24, 0x01	; 1
 5f6:	f1 f7       	brne	.-4      	; 0x5f4 <TWI_stop+0xa>
 5f8:	00 c0       	rjmp	.+0      	; 0x5fa <TWI_stop+0x10>
 5fa:	00 00       	nop
 5fc:	08 95       	ret

000005fe <TWI_write>:
    _delay_ms(1);  // Small delay to ensure the stop condition is transmitted
}

// Write byte to TWI bus
void TWI_write(uint8_t data) {
    TWDR = data;
 5fe:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
    TWCR = (1 << TWINT) | (1 << TWEN);
 602:	84 e8       	ldi	r24, 0x84	; 132
 604:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    while (!(TWCR & (1 << TWINT)));  // Wait for TWINT flag
 608:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
 60c:	88 23       	and	r24, r24
 60e:	e4 f7       	brge	.-8      	; 0x608 <TWI_write+0xa>
}
 610:	08 95       	ret

00000612 <TWI_read_ack>:

// Read byte from TWI bus with ACK
uint8_t TWI_read_ack(void) {
    TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
 612:	84 ec       	ldi	r24, 0xC4	; 196
 614:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    while (!(TWCR & (1 << TWINT)));
 618:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
 61c:	88 23       	and	r24, r24
 61e:	e4 f7       	brge	.-8      	; 0x618 <TWI_read_ack+0x6>
    return TWDR;
 620:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
}
 624:	08 95       	ret

00000626 <TWI_read_nack>:

// Read byte from TWI bus with NACK
uint8_t TWI_read_nack(void) {
    TWCR = (1 << TWINT) | (1 << TWEN);
 626:	84 e8       	ldi	r24, 0x84	; 132
 628:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    while (!(TWCR & (1 << TWINT)));
 62c:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
 630:	88 23       	and	r24, r24
 632:	e4 f7       	brge	.-8      	; 0x62c <TWI_read_nack+0x6>
    return TWDR;
 634:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
}
 638:	08 95       	ret

0000063a <TWI_get_distance>:

// Get distance from ultrasonic sensor via I2C
uint16_t TWI_get_distance(void) {
 63a:	cf 93       	push	r28
 63c:	df 93       	push	r29
    uint16_t distance = 0;
    uint8_t low_byte, high_byte;
    
    // Send command to slave to take distance measurement
    TWI_start();
 63e:	cd df       	rcall	.-102    	; 0x5da <TWI_start>
    TWI_write((SLAVE_ADDR << 1) | 0); // SLA+W
 640:	80 e2       	ldi	r24, 0x20	; 32
 642:	dd df       	rcall	.-70     	; 0x5fe <TWI_write>
    TWI_write(CMD_CHECK_DISTANCE);
 644:	8b e0       	ldi	r24, 0x0B	; 11
 646:	db df       	rcall	.-74     	; 0x5fe <TWI_write>
    TWI_write(0); // Dummy data
 648:	80 e0       	ldi	r24, 0x00	; 0
 64a:	d9 df       	rcall	.-78     	; 0x5fe <TWI_write>
 64c:	ce df       	rcall	.-100    	; 0x5ea <TWI_stop>
    TWI_stop();
 64e:	2f ef       	ldi	r18, 0xFF	; 255
 650:	80 e7       	ldi	r24, 0x70	; 112
 652:	92 e0       	ldi	r25, 0x02	; 2
 654:	21 50       	subi	r18, 0x01	; 1
 656:	80 40       	sbci	r24, 0x00	; 0
 658:	90 40       	sbci	r25, 0x00	; 0
 65a:	e1 f7       	brne	.-8      	; 0x654 <TWI_get_distance+0x1a>
 65c:	00 c0       	rjmp	.+0      	; 0x65e <TWI_get_distance+0x24>
 65e:	00 00       	nop
    
    _delay_ms(50); // Give slave time to measure
    
    // Read distance data (2 bytes) from slave
    TWI_start();
 660:	bc df       	rcall	.-136    	; 0x5da <TWI_start>
    TWI_write((SLAVE_ADDR << 1) | 1); // SLA+R
 662:	81 e2       	ldi	r24, 0x21	; 33
 664:	cc df       	rcall	.-104    	; 0x5fe <TWI_write>
    low_byte = TWI_read_ack();        // Read low byte with ACK
 666:	d5 df       	rcall	.-86     	; 0x612 <TWI_read_ack>
 668:	d8 2f       	mov	r29, r24
 66a:	dd df       	rcall	.-70     	; 0x626 <TWI_read_nack>
    high_byte = TWI_read_nack();      // Read high byte with NACK
 66c:	c8 2f       	mov	r28, r24
 66e:	bd df       	rcall	.-134    	; 0x5ea <TWI_stop>
 670:	8c 2f       	mov	r24, r28
    TWI_stop();
 672:	90 e0       	ldi	r25, 0x00	; 0
 674:	98 2f       	mov	r25, r24
    
    // Combine bytes
    distance = (high_byte << 8) | low_byte;
 676:	88 27       	eor	r24, r24
 678:	8d 2b       	or	r24, r29
 67a:	df 91       	pop	r29
 67c:	cf 91       	pop	r28
    
    return distance;
}
 67e:	08 95       	ret

00000680 <TWI_send_command_safe>:
 680:	cf 93       	push	r28
 682:	df 93       	push	r29
 684:	d8 2f       	mov	r29, r24

// Send command and data to slave
uint8_t TWI_send_command_safe(uint8_t command, uint8_t data) {
 686:	c6 2f       	mov	r28, r22
    // Visual feedback for I2C communication
    DEBUG_LED_PORT |= (1 << DEBUG_LED_PIN);
 688:	85 b1       	in	r24, 0x05	; 5
 68a:	80 68       	ori	r24, 0x80	; 128
 68c:	85 b9       	out	0x05, r24	; 5
    
    TWI_start();
 68e:	a5 df       	rcall	.-182    	; 0x5da <TWI_start>
    
    // Send slave address
    TWDR = (SLAVE_ADDR << 1) | 0;  // SLA+W
 690:	80 e2       	ldi	r24, 0x20	; 32
 692:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
    TWCR = (1 << TWINT) | (1 << TWEN);
 696:	84 e8       	ldi	r24, 0x84	; 132
 698:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    while (!(TWCR & (1 << TWINT)));
 69c:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
 6a0:	88 23       	and	r24, r24
 6a2:	e4 f7       	brge	.-8      	; 0x69c <TWI_send_command_safe+0x1c>
    
    if ((TWSR & 0xF8) != TW_MT_SLA_ACK) {
 6a4:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7c00b9>
 6a8:	88 7f       	andi	r24, 0xF8	; 248
 6aa:	88 31       	cpi	r24, 0x18	; 24
        TWI_stop();
 6ac:	49 f0       	breq	.+18     	; 0x6c0 <TWI_send_command_safe+0x40>
 6ae:	9d df       	rcall	.-198    	; 0x5ea <TWI_stop>
        DEBUG_LED_PORT &= ~(1 << DEBUG_LED_PIN);
 6b0:	85 b1       	in	r24, 0x05	; 5
 6b2:	8f 77       	andi	r24, 0x7F	; 127
 6b4:	85 b9       	out	0x05, r24	; 5
        communication_error = 1;
 6b6:	81 e0       	ldi	r24, 0x01	; 1
 6b8:	80 93 4f 03 	sts	0x034F, r24	; 0x80034f <communication_error>
        return 0;
 6bc:	80 e0       	ldi	r24, 0x00	; 0
 6be:	19 c0       	rjmp	.+50     	; 0x6f2 <TWI_send_command_safe+0x72>
    }
    
    // Send command byte
    TWDR = command;
 6c0:	d0 93 bb 00 	sts	0x00BB, r29	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
    TWCR = (1 << TWINT) | (1 << TWEN);
 6c4:	84 e8       	ldi	r24, 0x84	; 132
 6c6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    while (!(TWCR & (1 << TWINT)));
 6ca:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
 6ce:	88 23       	and	r24, r24
 6d0:	e4 f7       	brge	.-8      	; 0x6ca <TWI_send_command_safe+0x4a>
    
    // Send data byte
    TWDR = data;
 6d2:	c0 93 bb 00 	sts	0x00BB, r28	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7c00bb>
    TWCR = (1 << TWINT) | (1 << TWEN);
 6d6:	84 e8       	ldi	r24, 0x84	; 132
 6d8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
    while (!(TWCR & (1 << TWINT)));
 6dc:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7c00bc>
 6e0:	88 23       	and	r24, r24
    
    // Stop condition
    TWI_stop();
 6e2:	e4 f7       	brge	.-8      	; 0x6dc <TWI_send_command_safe+0x5c>
 6e4:	82 df       	rcall	.-252    	; 0x5ea <TWI_stop>
    
    DEBUG_LED_PORT &= ~(1 << DEBUG_LED_PIN);
 6e6:	85 b1       	in	r24, 0x05	; 5
 6e8:	8f 77       	andi	r24, 0x7F	; 127
 6ea:	85 b9       	out	0x05, r24	; 5
    communication_error = 0;
 6ec:	10 92 4f 03 	sts	0x034F, r1	; 0x80034f <communication_error>
    return 1;  // Success
 6f0:	81 e0       	ldi	r24, 0x01	; 1
}
 6f2:	df 91       	pop	r29
 6f4:	cf 91       	pop	r28
 6f6:	08 95       	ret

000006f8 <safe_get_keypad_input>:

// Get keypad input with simple debounce
uint8_t safe_get_keypad_input(void) {
    uint8_t key = KEYPAD_GetKey();
 6f8:	df dd       	rcall	.-1090   	; 0x2b8 <KEYPAD_GetKey>
    
    // If a key is detected, return it after brief debounce delay
    if (key != 0xFF) {
 6fa:	8f 3f       	cpi	r24, 0xFF	; 255
 6fc:	51 f0       	breq	.+20     	; 0x712 <safe_get_keypad_input+0x1a>
 6fe:	2f ef       	ldi	r18, 0xFF	; 255
 700:	39 ef       	ldi	r19, 0xF9	; 249
 702:	90 e0       	ldi	r25, 0x00	; 0
 704:	21 50       	subi	r18, 0x01	; 1
 706:	30 40       	sbci	r19, 0x00	; 0
 708:	90 40       	sbci	r25, 0x00	; 0
 70a:	e1 f7       	brne	.-8      	; 0x704 <safe_get_keypad_input+0xc>
 70c:	00 c0       	rjmp	.+0      	; 0x70e <safe_get_keypad_input+0x16>
 70e:	00 00       	nop
        _delay_ms(20);  // Debounce delay
        return key;
 710:	08 95       	ret
    }
    return 0xFF;  // No key pressed
 712:	8f ef       	ldi	r24, 0xFF	; 255
}
 714:	08 95       	ret

00000716 <debug_blink>:

// Debug visual feedback via LED
void debug_blink(uint8_t times) {
    for (uint8_t i = 0; i < times; i++) {
 716:	20 e0       	ldi	r18, 0x00	; 0
 718:	19 c0       	rjmp	.+50     	; 0x74c <debug_blink+0x36>
        DEBUG_LED_PORT |= (1 << DEBUG_LED_PIN);
 71a:	95 b1       	in	r25, 0x05	; 5
 71c:	90 68       	ori	r25, 0x80	; 128
 71e:	95 b9       	out	0x05, r25	; 5
 720:	3f ef       	ldi	r19, 0xFF	; 255
 722:	43 ec       	ldi	r20, 0xC3	; 195
 724:	99 e0       	ldi	r25, 0x09	; 9
 726:	31 50       	subi	r19, 0x01	; 1
 728:	40 40       	sbci	r20, 0x00	; 0
 72a:	90 40       	sbci	r25, 0x00	; 0
 72c:	e1 f7       	brne	.-8      	; 0x726 <debug_blink+0x10>
 72e:	00 c0       	rjmp	.+0      	; 0x730 <debug_blink+0x1a>
 730:	00 00       	nop
        _delay_ms(200);
        DEBUG_LED_PORT &= ~(1 << DEBUG_LED_PIN);
 732:	95 b1       	in	r25, 0x05	; 5
 734:	9f 77       	andi	r25, 0x7F	; 127
 736:	95 b9       	out	0x05, r25	; 5
 738:	3f ef       	ldi	r19, 0xFF	; 255
 73a:	43 ec       	ldi	r20, 0xC3	; 195
 73c:	99 e0       	ldi	r25, 0x09	; 9
 73e:	31 50       	subi	r19, 0x01	; 1
 740:	40 40       	sbci	r20, 0x00	; 0
 742:	90 40       	sbci	r25, 0x00	; 0
 744:	e1 f7       	brne	.-8      	; 0x73e <debug_blink+0x28>
 746:	00 c0       	rjmp	.+0      	; 0x748 <debug_blink+0x32>
 748:	00 00       	nop
    return 0xFF;  // No key pressed
}

// Debug visual feedback via LED
void debug_blink(uint8_t times) {
    for (uint8_t i = 0; i < times; i++) {
 74a:	2f 5f       	subi	r18, 0xFF	; 255
 74c:	28 17       	cp	r18, r24
 74e:	28 f3       	brcs	.-54     	; 0x71a <debug_blink+0x4>
        DEBUG_LED_PORT |= (1 << DEBUG_LED_PIN);
        _delay_ms(200);
        DEBUG_LED_PORT &= ~(1 << DEBUG_LED_PIN);
        _delay_ms(200);
    }
}
 750:	08 95       	ret

00000752 <clear_input_buffer>:
    }
}

// Clear the input buffer
void clear_input_buffer(void) {
    for (uint8_t i = 0; i < 3; i++) {
 752:	80 e0       	ldi	r24, 0x00	; 0
 754:	06 c0       	rjmp	.+12     	; 0x762 <clear_input_buffer+0x10>
        input_buffer[i] = 0;
 756:	e8 2f       	mov	r30, r24
 758:	f0 e0       	ldi	r31, 0x00	; 0
 75a:	ec 5a       	subi	r30, 0xAC	; 172
 75c:	fc 4f       	sbci	r31, 0xFC	; 252
 75e:	10 82       	st	Z, r1
    }
}

// Clear the input buffer
void clear_input_buffer(void) {
    for (uint8_t i = 0; i < 3; i++) {
 760:	8f 5f       	subi	r24, 0xFF	; 255
 762:	83 30       	cpi	r24, 0x03	; 3
 764:	c0 f3       	brcs	.-16     	; 0x756 <clear_input_buffer+0x4>
        input_buffer[i] = 0;
    }
    input_index = 0;
 766:	10 92 53 03 	sts	0x0353, r1	; 0x800353 <input_index>
 76a:	08 95       	ret

0000076c <convert_input_to_floor>:
}

// Convert input buffer to floor number
uint8_t convert_input_to_floor(void) {
    if (input_index == 0) {
 76c:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <input_index>
 770:	88 23       	and	r24, r24
 772:	89 f0       	breq	.+34     	; 0x796 <convert_input_to_floor+0x2a>
        return 0;
    }
    else if (input_index == 1) {
 774:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <input_index>
 778:	81 30       	cpi	r24, 0x01	; 1
 77a:	19 f4       	brne	.+6      	; 0x782 <convert_input_to_floor+0x16>
        return input_buffer[0];  // Single-digit floor
 77c:	80 91 54 03 	lds	r24, 0x0354	; 0x800354 <input_buffer>
 780:	08 95       	ret
    }
    else {
        return input_buffer[0] * 10 + input_buffer[1];  // Two-digit floor
 782:	e4 e5       	ldi	r30, 0x54	; 84
 784:	f3 e0       	ldi	r31, 0x03	; 3
 786:	80 81       	ld	r24, Z
 788:	91 81       	ldd	r25, Z+1	; 0x01
 78a:	88 0f       	add	r24, r24
 78c:	28 2f       	mov	r18, r24
 78e:	22 0f       	add	r18, r18
 790:	22 0f       	add	r18, r18
 792:	82 0f       	add	r24, r18
 794:	89 0f       	add	r24, r25
    }
}
 796:	08 95       	ret

00000798 <update_display>:
            break;
    }
}

// Update LCD display based on current state
void update_display(void) {
 798:	cf 93       	push	r28
 79a:	df 93       	push	r29
 79c:	00 d0       	rcall	.+0      	; 0x79e <update_display+0x6>
 79e:	1f 92       	push	r1
 7a0:	1f 92       	push	r1
 7a2:	cd b7       	in	r28, 0x3d	; 61
 7a4:	de b7       	in	r29, 0x3e	; 62
    lcd_clrscr();
 7a6:	9b de       	rcall	.-714    	; 0x4de <lcd_clrscr>
    
    // If there was a communication error, show it briefly
    if (communication_error) {
 7a8:	80 91 4f 03 	lds	r24, 0x034F	; 0x80034f <communication_error>
 7ac:	88 23       	and	r24, r24
 7ae:	71 f0       	breq	.+28     	; 0x7cc <update_display+0x34>
        lcd_puts("I2C Error!");
 7b0:	80 e0       	ldi	r24, 0x00	; 0
 7b2:	92 e0       	ldi	r25, 0x02	; 2
 7b4:	a9 de       	rcall	.-686    	; 0x508 <lcd_puts>
 7b6:	2f ef       	ldi	r18, 0xFF	; 255
 7b8:	89 e6       	ldi	r24, 0x69	; 105
 7ba:	98 e1       	ldi	r25, 0x18	; 24
 7bc:	21 50       	subi	r18, 0x01	; 1
 7be:	80 40       	sbci	r24, 0x00	; 0
 7c0:	90 40       	sbci	r25, 0x00	; 0
 7c2:	e1 f7       	brne	.-8      	; 0x7bc <update_display+0x24>
 7c4:	00 c0       	rjmp	.+0      	; 0x7c6 <update_display+0x2e>
 7c6:	00 00       	nop
        _delay_ms(500);
        communication_error = 0;
 7c8:	10 92 4f 03 	sts	0x034F, r1	; 0x80034f <communication_error>
    }
    
    switch (current_state) {
 7cc:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
 7d0:	90 e0       	ldi	r25, 0x00	; 0
 7d2:	88 30       	cpi	r24, 0x08	; 8
 7d4:	91 05       	cpc	r25, r1
 7d6:	08 f0       	brcs	.+2      	; 0x7da <update_display+0x42>
 7d8:	98 c0       	rjmp	.+304    	; 0x90a <update_display+0x172>
 7da:	fc 01       	movw	r30, r24
 7dc:	88 27       	eor	r24, r24
 7de:	e6 51       	subi	r30, 0x16	; 22
 7e0:	ff 4f       	sbci	r31, 0xFF	; 255
 7e2:	8f 4f       	sbci	r24, 0xFF	; 255
 7e4:	89 c3       	rjmp	.+1810   	; 0xef8 <__tablejump2__>
        case STATE_IDLE:
            lcd_puts("Choose floor:");
 7e6:	8b e0       	ldi	r24, 0x0B	; 11
 7e8:	92 e0       	ldi	r25, 0x02	; 2
 7ea:	8e de       	rcall	.-740    	; 0x508 <lcd_puts>
            lcd_gotoxy(0, 1);
 7ec:	61 e0       	ldi	r22, 0x01	; 1
 7ee:	80 e0       	ldi	r24, 0x00	; 0
 7f0:	6e de       	rcall	.-804    	; 0x4ce <lcd_gotoxy>
            
            // Show current input if any
            if (input_index > 0) {
 7f2:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <input_index>
 7f6:	88 23       	and	r24, r24
 7f8:	59 f0       	breq	.+22     	; 0x810 <update_display+0x78>
                char buffer[5];
                uint8_t floor = convert_input_to_floor();
 7fa:	b8 df       	rcall	.-144    	; 0x76c <convert_input_to_floor>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 7fc:	4a e0       	ldi	r20, 0x0A	; 10
 7fe:	be 01       	movw	r22, r28
 800:	6f 5f       	subi	r22, 0xFF	; 255
 802:	7f 4f       	sbci	r23, 0xFF	; 255
 804:	90 e0       	ldi	r25, 0x00	; 0
 806:	80 d3       	rcall	.+1792   	; 0xf08 <__itoa_ncheck>
                itoa(floor, buffer, 10);
                lcd_puts(buffer);
 808:	ce 01       	movw	r24, r28
 80a:	01 96       	adiw	r24, 0x01	; 1
 80c:	7d de       	rcall	.-774    	; 0x508 <lcd_puts>
 80e:	7d c0       	rjmp	.+250    	; 0x90a <update_display+0x172>
 810:	89 e1       	ldi	r24, 0x19	; 25
            } else {
                lcd_puts("Current: ");
 812:	92 e0       	ldi	r25, 0x02	; 2
 814:	79 de       	rcall	.-782    	; 0x508 <lcd_puts>
 816:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
 81a:	4a e0       	ldi	r20, 0x0A	; 10
 81c:	be 01       	movw	r22, r28
 81e:	6f 5f       	subi	r22, 0xFF	; 255
 820:	7f 4f       	sbci	r23, 0xFF	; 255
 822:	90 e0       	ldi	r25, 0x00	; 0
 824:	71 d3       	rcall	.+1762   	; 0xf08 <__itoa_ncheck>
                char buffer[5];
                itoa(current_floor, buffer, 10);
                lcd_puts(buffer);
 826:	ce 01       	movw	r24, r28
 828:	01 96       	adiw	r24, 0x01	; 1
 82a:	6e de       	rcall	.-804    	; 0x508 <lcd_puts>
 82c:	6e c0       	rjmp	.+220    	; 0x90a <update_display+0x172>
            }
            break;
            
        case STATE_MOVING_UP:
            lcd_puts("Going up");
 82e:	83 e2       	ldi	r24, 0x23	; 35
 830:	92 e0       	ldi	r25, 0x02	; 2
 832:	6a de       	rcall	.-812    	; 0x508 <lcd_puts>
 834:	61 e0       	ldi	r22, 0x01	; 1
            lcd_gotoxy(0, 1);
 836:	80 e0       	ldi	r24, 0x00	; 0
 838:	4a de       	rcall	.-876    	; 0x4ce <lcd_gotoxy>
 83a:	8c e2       	ldi	r24, 0x2C	; 44
            lcd_puts("Floor: ");
 83c:	92 e0       	ldi	r25, 0x02	; 2
 83e:	64 de       	rcall	.-824    	; 0x508 <lcd_puts>
 840:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
 844:	4a e0       	ldi	r20, 0x0A	; 10
 846:	be 01       	movw	r22, r28
 848:	6f 5f       	subi	r22, 0xFF	; 255
 84a:	7f 4f       	sbci	r23, 0xFF	; 255
 84c:	90 e0       	ldi	r25, 0x00	; 0
            char up_buffer[5];
            itoa(current_floor, up_buffer, 10);
            lcd_puts(up_buffer);
 84e:	5c d3       	rcall	.+1720   	; 0xf08 <__itoa_ncheck>
 850:	ce 01       	movw	r24, r28
 852:	01 96       	adiw	r24, 0x01	; 1
 854:	59 de       	rcall	.-846    	; 0x508 <lcd_puts>
            break;
 856:	59 c0       	rjmp	.+178    	; 0x90a <update_display+0x172>
            
        case STATE_MOVING_DOWN:
            lcd_puts("Going down");
 858:	84 e3       	ldi	r24, 0x34	; 52
 85a:	92 e0       	ldi	r25, 0x02	; 2
 85c:	55 de       	rcall	.-854    	; 0x508 <lcd_puts>
            lcd_gotoxy(0, 1);
 85e:	61 e0       	ldi	r22, 0x01	; 1
 860:	80 e0       	ldi	r24, 0x00	; 0
 862:	35 de       	rcall	.-918    	; 0x4ce <lcd_gotoxy>
            lcd_puts("Floor: ");
 864:	8c e2       	ldi	r24, 0x2C	; 44
 866:	92 e0       	ldi	r25, 0x02	; 2
 868:	4f de       	rcall	.-866    	; 0x508 <lcd_puts>
 86a:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
            char down_buffer[5];
            itoa(current_floor, down_buffer, 10);
 86e:	4a e0       	ldi	r20, 0x0A	; 10
 870:	be 01       	movw	r22, r28
 872:	6f 5f       	subi	r22, 0xFF	; 255
 874:	7f 4f       	sbci	r23, 0xFF	; 255
 876:	90 e0       	ldi	r25, 0x00	; 0
 878:	47 d3       	rcall	.+1678   	; 0xf08 <__itoa_ncheck>
            lcd_puts(down_buffer);
 87a:	ce 01       	movw	r24, r28
 87c:	01 96       	adiw	r24, 0x01	; 1
 87e:	44 de       	rcall	.-888    	; 0x508 <lcd_puts>
            break;
 880:	44 c0       	rjmp	.+136    	; 0x90a <update_display+0x172>
            
        case STATE_DOOR_OPEN:
            lcd_puts("Floor: ");
 882:	8c e2       	ldi	r24, 0x2C	; 44
 884:	92 e0       	ldi	r25, 0x02	; 2
 886:	40 de       	rcall	.-896    	; 0x508 <lcd_puts>
            char floor_buffer[5];
            itoa(current_floor, floor_buffer, 10);
 888:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
 88c:	4a e0       	ldi	r20, 0x0A	; 10
 88e:	be 01       	movw	r22, r28
 890:	6f 5f       	subi	r22, 0xFF	; 255
 892:	7f 4f       	sbci	r23, 0xFF	; 255
 894:	90 e0       	ldi	r25, 0x00	; 0
            lcd_puts(floor_buffer);
 896:	38 d3       	rcall	.+1648   	; 0xf08 <__itoa_ncheck>
 898:	ce 01       	movw	r24, r28
 89a:	01 96       	adiw	r24, 0x01	; 1
            lcd_gotoxy(0, 1);
 89c:	35 de       	rcall	.-918    	; 0x508 <lcd_puts>
 89e:	61 e0       	ldi	r22, 0x01	; 1
 8a0:	80 e0       	ldi	r24, 0x00	; 0
            lcd_puts("Door is open");
 8a2:	15 de       	rcall	.-982    	; 0x4ce <lcd_gotoxy>
 8a4:	8f e3       	ldi	r24, 0x3F	; 63
 8a6:	92 e0       	ldi	r25, 0x02	; 2
            break;
 8a8:	2f de       	rcall	.-930    	; 0x508 <lcd_puts>
            
        case STATE_EMERGENCY:
            lcd_puts("EMERGENCY");
 8aa:	2f c0       	rjmp	.+94     	; 0x90a <update_display+0x172>
 8ac:	8c e4       	ldi	r24, 0x4C	; 76
 8ae:	92 e0       	ldi	r25, 0x02	; 2
            lcd_gotoxy(0, 1);
 8b0:	2b de       	rcall	.-938    	; 0x508 <lcd_puts>
 8b2:	61 e0       	ldi	r22, 0x01	; 1
 8b4:	80 e0       	ldi	r24, 0x00	; 0
            
            if (!door_open) {
 8b6:	0b de       	rcall	.-1002   	; 0x4ce <lcd_gotoxy>
 8b8:	80 91 51 03 	lds	r24, 0x0351	; 0x800351 <door_open>
                lcd_puts("* to open door");
 8bc:	81 11       	cpse	r24, r1
 8be:	04 c0       	rjmp	.+8      	; 0x8c8 <update_display+0x130>
 8c0:	86 e5       	ldi	r24, 0x56	; 86
 8c2:	92 e0       	ldi	r25, 0x02	; 2
            } else {
                lcd_puts("# to stop alarm");
 8c4:	21 de       	rcall	.-958    	; 0x508 <lcd_puts>
 8c6:	21 c0       	rjmp	.+66     	; 0x90a <update_display+0x172>
 8c8:	85 e6       	ldi	r24, 0x65	; 101
            }
            break;
            
        case STATE_FAULT:
            lcd_puts("ERROR");
 8ca:	92 e0       	ldi	r25, 0x02	; 2
 8cc:	1d de       	rcall	.-966    	; 0x508 <lcd_puts>
 8ce:	1d c0       	rjmp	.+58     	; 0x90a <update_display+0x172>
 8d0:	85 e7       	ldi	r24, 0x75	; 117
            lcd_gotoxy(0, 1);
 8d2:	92 e0       	ldi	r25, 0x02	; 2
 8d4:	19 de       	rcall	.-974    	; 0x508 <lcd_puts>
 8d6:	61 e0       	ldi	r22, 0x01	; 1
 8d8:	80 e0       	ldi	r24, 0x00	; 0
            lcd_puts("Already at floor");
 8da:	f9 dd       	rcall	.-1038   	; 0x4ce <lcd_gotoxy>
 8dc:	8b e7       	ldi	r24, 0x7B	; 123
 8de:	92 e0       	ldi	r25, 0x02	; 2
 8e0:	13 de       	rcall	.-986    	; 0x508 <lcd_puts>
            break;
 8e2:	13 c0       	rjmp	.+38     	; 0x90a <update_display+0x172>
            
        case STATE_MAINTENANCE:
            lcd_puts("Maintenance");
 8e4:	8c e8       	ldi	r24, 0x8C	; 140
 8e6:	92 e0       	ldi	r25, 0x02	; 2
 8e8:	0f de       	rcall	.-994    	; 0x508 <lcd_puts>
 8ea:	61 e0       	ldi	r22, 0x01	; 1
            lcd_gotoxy(0, 1);
 8ec:	80 e0       	ldi	r24, 0x00	; 0
 8ee:	ef dd       	rcall	.-1058   	; 0x4ce <lcd_gotoxy>
 8f0:	88 e9       	ldi	r24, 0x98	; 152
 8f2:	92 e0       	ldi	r25, 0x02	; 2
            lcd_puts("* to exit");
 8f4:	09 de       	rcall	.-1006   	; 0x508 <lcd_puts>
 8f6:	09 c0       	rjmp	.+18     	; 0x90a <update_display+0x172>
 8f8:	82 ea       	ldi	r24, 0xA2	; 162
 8fa:	92 e0       	ldi	r25, 0x02	; 2
            break;
 8fc:	05 de       	rcall	.-1014   	; 0x508 <lcd_puts>
            
        case STATE_OBSTRUCTION:
            lcd_puts("OBSTRUCTION");
 8fe:	61 e0       	ldi	r22, 0x01	; 1
 900:	80 e0       	ldi	r24, 0x00	; 0
 902:	e5 dd       	rcall	.-1078   	; 0x4ce <lcd_gotoxy>
 904:	8e ea       	ldi	r24, 0xAE	; 174
            lcd_gotoxy(0, 1);
 906:	92 e0       	ldi	r25, 0x02	; 2
 908:	ff dd       	rcall	.-1026   	; 0x508 <lcd_puts>
 90a:	0f 90       	pop	r0
 90c:	0f 90       	pop	r0
            lcd_puts("Please wait...");
 90e:	0f 90       	pop	r0
 910:	0f 90       	pop	r0
 912:	0f 90       	pop	r0
 914:	df 91       	pop	r29
            break;
    }
}
 916:	cf 91       	pop	r28
 918:	08 95       	ret

0000091a <handle_maintenance_mode>:
 91a:	60 e0       	ldi	r22, 0x00	; 0
 91c:	8a e0       	ldi	r24, 0x0A	; 10
 91e:	b0 de       	rcall	.-672    	; 0x680 <TWI_send_command_safe>
 920:	3b cf       	rjmp	.-394    	; 0x798 <update_display>
 922:	08 95       	ret

00000924 <set_state>:
 924:	80 93 59 03 	sts	0x0359, r24	; 0x800359 <current_state>
    
    // Send command to slave based on new state
    uint8_t command = CMD_IDLE;
    uint8_t data = 0;
    
    switch (new_state) {
 928:	83 30       	cpi	r24, 0x03	; 3
 92a:	f9 f0       	breq	.+62     	; 0x96a <set_state+0x46>
 92c:	28 f4       	brcc	.+10     	; 0x938 <set_state+0x14>
 92e:	81 30       	cpi	r24, 0x01	; 1
 930:	59 f0       	breq	.+22     	; 0x948 <set_state+0x24>
 932:	82 30       	cpi	r24, 0x02	; 2
 934:	69 f0       	breq	.+26     	; 0x950 <set_state+0x2c>
 936:	05 c0       	rjmp	.+10     	; 0x942 <set_state+0x1e>
 938:	85 30       	cpi	r24, 0x05	; 5
 93a:	89 f0       	breq	.+34     	; 0x95e <set_state+0x3a>
 93c:	68 f0       	brcs	.+26     	; 0x958 <set_state+0x34>
 93e:	86 30       	cpi	r24, 0x06	; 6
 940:	89 f0       	breq	.+34     	; 0x964 <set_state+0x40>
void set_state(ElevatorState new_state) {
    current_state = new_state;
    
    // Send command to slave based on new state
    uint8_t command = CMD_IDLE;
    uint8_t data = 0;
 942:	60 e0       	ldi	r22, 0x00	; 0
// Set system state and send corresponding command to slave
void set_state(ElevatorState new_state) {
    current_state = new_state;
    
    // Send command to slave based on new state
    uint8_t command = CMD_IDLE;
 944:	80 e0       	ldi	r24, 0x00	; 0
 946:	13 c0       	rjmp	.+38     	; 0x96e <set_state+0x4a>
        case STATE_IDLE:
            command = CMD_IDLE;
            break;
        case STATE_MOVING_UP:
            command = CMD_MOVING_UP;
            data = target_floor;
 948:	60 91 57 03 	lds	r22, 0x0357	; 0x800357 <target_floor>
    switch (new_state) {
        case STATE_IDLE:
            command = CMD_IDLE;
            break;
        case STATE_MOVING_UP:
            command = CMD_MOVING_UP;
 94c:	81 e0       	ldi	r24, 0x01	; 1
            data = target_floor;
            break;
 94e:	0f c0       	rjmp	.+30     	; 0x96e <set_state+0x4a>
        case STATE_MOVING_DOWN:
            command = CMD_MOVING_DOWN;
            data = target_floor;
 950:	60 91 57 03 	lds	r22, 0x0357	; 0x800357 <target_floor>
        case STATE_MOVING_UP:
            command = CMD_MOVING_UP;
            data = target_floor;
            break;
        case STATE_MOVING_DOWN:
            command = CMD_MOVING_DOWN;
 954:	82 e0       	ldi	r24, 0x02	; 2
            data = target_floor;
            break;
 956:	0b c0       	rjmp	.+22     	; 0x96e <set_state+0x4a>
void set_state(ElevatorState new_state) {
    current_state = new_state;
    
    // Send command to slave based on new state
    uint8_t command = CMD_IDLE;
    uint8_t data = 0;
 958:	60 e0       	ldi	r22, 0x00	; 0
        case STATE_DOOR_OPEN:
            command = CMD_DOOR_OPEN;
            data = 1;  // 1 = door open
            break;
        case STATE_EMERGENCY:
            command = CMD_EMERGENCY;
 95a:	85 e0       	ldi	r24, 0x05	; 5
            break;
 95c:	08 c0       	rjmp	.+16     	; 0x96e <set_state+0x4a>
void set_state(ElevatorState new_state) {
    current_state = new_state;
    
    // Send command to slave based on new state
    uint8_t command = CMD_IDLE;
    uint8_t data = 0;
 95e:	60 e0       	ldi	r22, 0x00	; 0
            break;
        case STATE_EMERGENCY:
            command = CMD_EMERGENCY;
            break;
        case STATE_FAULT:
            command = CMD_FAULT;
 960:	86 e0       	ldi	r24, 0x06	; 6
            break;
 962:	05 c0       	rjmp	.+10     	; 0x96e <set_state+0x4a>
void set_state(ElevatorState new_state) {
    current_state = new_state;
    
    // Send command to slave based on new state
    uint8_t command = CMD_IDLE;
    uint8_t data = 0;
 964:	60 e0       	ldi	r22, 0x00	; 0
            break;
        case STATE_FAULT:
            command = CMD_FAULT;
            break;
        case STATE_MAINTENANCE:
            command = CMD_MAINTENANCE;  // New maintenance command
 966:	8a e0       	ldi	r24, 0x0A	; 10
            break;
 968:	02 c0       	rjmp	.+4      	; 0x96e <set_state+0x4a>
            command = CMD_MOVING_DOWN;
            data = target_floor;
            break;
        case STATE_DOOR_OPEN:
            command = CMD_DOOR_OPEN;
            data = 1;  // 1 = door open
 96a:	61 e0       	ldi	r22, 0x01	; 1
        case STATE_MOVING_DOWN:
            command = CMD_MOVING_DOWN;
            data = target_floor;
            break;
        case STATE_DOOR_OPEN:
            command = CMD_DOOR_OPEN;
 96c:	83 e0       	ldi	r24, 0x03	; 3
            // No specific slave command needed, just pause operation
            break;
    }
    
    // Send command to slave
    TWI_send_command_safe(command, data);
 96e:	88 de       	rcall	.-752    	; 0x680 <TWI_send_command_safe>
    
    // Update display
    update_display();
 970:	13 cf       	rjmp	.-474    	; 0x798 <update_display>
 972:	08 95       	ret

00000974 <system_init>:
 974:	84 b1       	in	r24, 0x04	; 4
}

// Initialize the system
void system_init(void) {
    // Setup debug LED
    DEBUG_LED_DDR |= (1 << DEBUG_LED_PIN);
 976:	80 68       	ori	r24, 0x80	; 128
 978:	84 b9       	out	0x04, r24	; 4
    DEBUG_LED_PORT &= ~(1 << DEBUG_LED_PIN);
 97a:	85 b1       	in	r24, 0x05	; 5
 97c:	8f 77       	andi	r24, 0x7F	; 127
 97e:	85 b9       	out	0x05, r24	; 5
    
    // Initialize state variables explicitly
    emergency_flag = 0;
 980:	10 92 52 03 	sts	0x0352, r1	; 0x800352 <emergency_flag>
    door_open = 0;
 984:	10 92 51 03 	sts	0x0351, r1	; 0x800351 <door_open>
    melody_playing = 0;
 988:	10 92 50 03 	sts	0x0350, r1	; 0x800350 <melody_playing>
    maintenance_mode = 0;
 98c:	10 92 4e 03 	sts	0x034E, r1	; 0x80034e <maintenance_mode>
    
    // Blink once to show system starting
    debug_blink(1);
 990:	81 e0       	ldi	r24, 0x01	; 1
 992:	c1 de       	rcall	.-638    	; 0x716 <debug_blink>
    
    // Initialize LCD
    lcd_init(LCD_DISP_ON);
 994:	8c e0       	ldi	r24, 0x0C	; 12
    lcd_clrscr();
 996:	c6 dd       	rcall	.-1140   	; 0x524 <lcd_init>
    lcd_puts("Elevator System");
 998:	a2 dd       	rcall	.-1212   	; 0x4de <lcd_clrscr>
 99a:	8d eb       	ldi	r24, 0xBD	; 189
 99c:	92 e0       	ldi	r25, 0x02	; 2
    lcd_gotoxy(0, 1);
 99e:	b4 dd       	rcall	.-1176   	; 0x508 <lcd_puts>
 9a0:	61 e0       	ldi	r22, 0x01	; 1
 9a2:	80 e0       	ldi	r24, 0x00	; 0
    lcd_puts("Initializing...");
 9a4:	94 dd       	rcall	.-1240   	; 0x4ce <lcd_gotoxy>
 9a6:	8d ec       	ldi	r24, 0xCD	; 205
 9a8:	92 e0       	ldi	r25, 0x02	; 2
 9aa:	ae dd       	rcall	.-1188   	; 0x508 <lcd_puts>
 9ac:	2f ef       	ldi	r18, 0xFF	; 255
 9ae:	83 ed       	ldi	r24, 0xD3	; 211
 9b0:	90 e3       	ldi	r25, 0x30	; 48
 9b2:	21 50       	subi	r18, 0x01	; 1
 9b4:	80 40       	sbci	r24, 0x00	; 0
 9b6:	90 40       	sbci	r25, 0x00	; 0
 9b8:	e1 f7       	brne	.-8      	; 0x9b2 <system_init+0x3e>
    _delay_ms(1000);
    
    // Initialize keypad
    KEYPAD_Init();
 9ba:	00 c0       	rjmp	.+0      	; 0x9bc <system_init+0x48>
 9bc:	00 00       	nop
    lcd_clrscr();
 9be:	4a dc       	rcall	.-1900   	; 0x254 <KEYPAD_Init>
 9c0:	8e dd       	rcall	.-1252   	; 0x4de <lcd_clrscr>
    lcd_puts("Keypad Ready");
 9c2:	8d ed       	ldi	r24, 0xDD	; 221
 9c4:	92 e0       	ldi	r25, 0x02	; 2
 9c6:	a0 dd       	rcall	.-1216   	; 0x508 <lcd_puts>
 9c8:	2f ef       	ldi	r18, 0xFF	; 255
 9ca:	89 e6       	ldi	r24, 0x69	; 105
 9cc:	98 e1       	ldi	r25, 0x18	; 24
 9ce:	21 50       	subi	r18, 0x01	; 1
 9d0:	80 40       	sbci	r24, 0x00	; 0
 9d2:	90 40       	sbci	r25, 0x00	; 0
 9d4:	e1 f7       	brne	.-8      	; 0x9ce <system_init+0x5a>
 9d6:	00 c0       	rjmp	.+0      	; 0x9d8 <system_init+0x64>
    _delay_ms(500);
    
    // Configure emergency button input (pin 12)
    EMERGENCY_BTN_DDR &= ~(1 << EMERGENCY_BTN_BIT);  // Set as input
 9d8:	00 00       	nop
    // Not using internal pull-up since we have external resistor
    
    // Test the emergency button
    lcd_clrscr();
 9da:	84 b1       	in	r24, 0x04	; 4
 9dc:	8f 7b       	andi	r24, 0xBF	; 191
    lcd_puts("Button test");
 9de:	84 b9       	out	0x04, r24	; 4
 9e0:	7e dd       	rcall	.-1284   	; 0x4de <lcd_clrscr>
 9e2:	8a ee       	ldi	r24, 0xEA	; 234
    lcd_gotoxy(0, 1);
 9e4:	92 e0       	ldi	r25, 0x02	; 2
 9e6:	90 dd       	rcall	.-1248   	; 0x508 <lcd_puts>
 9e8:	61 e0       	ldi	r22, 0x01	; 1
    if (is_emergency_button_pressed()) {
 9ea:	80 e0       	ldi	r24, 0x00	; 0
 9ec:	70 dd       	rcall	.-1312   	; 0x4ce <lcd_gotoxy>
 9ee:	e3 dd       	rcall	.-1082   	; 0x5b6 <is_emergency_button_pressed>
 9f0:	88 23       	and	r24, r24
        lcd_puts("Button pressed!");
 9f2:	31 f0       	breq	.+12     	; 0xa00 <system_init+0x8c>
 9f4:	86 ef       	ldi	r24, 0xF6	; 246
 9f6:	92 e0       	ldi	r25, 0x02	; 2
 9f8:	87 dd       	rcall	.-1266   	; 0x508 <lcd_puts>
        debug_blink(3);
 9fa:	83 e0       	ldi	r24, 0x03	; 3
 9fc:	8c de       	rcall	.-744    	; 0x716 <debug_blink>
    } else {
        lcd_puts("Button ready");
 9fe:	03 c0       	rjmp	.+6      	; 0xa06 <system_init+0x92>
 a00:	86 e0       	ldi	r24, 0x06	; 6
 a02:	93 e0       	ldi	r25, 0x03	; 3
 a04:	81 dd       	rcall	.-1278   	; 0x508 <lcd_puts>
 a06:	2f ef       	ldi	r18, 0xFF	; 255
 a08:	83 ed       	ldi	r24, 0xD3	; 211
 a0a:	90 e3       	ldi	r25, 0x30	; 48
 a0c:	21 50       	subi	r18, 0x01	; 1
 a0e:	80 40       	sbci	r24, 0x00	; 0
 a10:	90 40       	sbci	r25, 0x00	; 0
 a12:	e1 f7       	brne	.-8      	; 0xa0c <system_init+0x98>
 a14:	00 c0       	rjmp	.+0      	; 0xa16 <system_init+0xa2>
    }
    _delay_ms(1000);
    
    // Initialize TWI as master
    TWI_init_master();
 a16:	00 00       	nop
    lcd_clrscr();
 a18:	d7 dd       	rcall	.-1106   	; 0x5c8 <TWI_init_master>
 a1a:	61 dd       	rcall	.-1342   	; 0x4de <lcd_clrscr>
    lcd_puts("I2C Ready");
 a1c:	83 e1       	ldi	r24, 0x13	; 19
 a1e:	93 e0       	ldi	r25, 0x03	; 3
 a20:	73 dd       	rcall	.-1306   	; 0x508 <lcd_puts>
 a22:	2f ef       	ldi	r18, 0xFF	; 255
 a24:	89 e6       	ldi	r24, 0x69	; 105
 a26:	98 e1       	ldi	r25, 0x18	; 24
 a28:	21 50       	subi	r18, 0x01	; 1
 a2a:	80 40       	sbci	r24, 0x00	; 0
 a2c:	90 40       	sbci	r25, 0x00	; 0
 a2e:	e1 f7       	brne	.-8      	; 0xa28 <system_init+0xb4>
 a30:	00 c0       	rjmp	.+0      	; 0xa32 <system_init+0xbe>
 a32:	00 00       	nop
    _delay_ms(500);
    
    // Enable global interrupts
    sei();
 a34:	78 94       	sei
    
    // Try to connect to the slave
    if (TWI_send_command_safe(CMD_IDLE, 0)) {
 a36:	60 e0       	ldi	r22, 0x00	; 0
 a38:	80 e0       	ldi	r24, 0x00	; 0
 a3a:	22 de       	rcall	.-956    	; 0x680 <TWI_send_command_safe>
 a3c:	88 23       	and	r24, r24
        lcd_clrscr();
 a3e:	71 f0       	breq	.+28     	; 0xa5c <system_init+0xe8>
        lcd_puts("Slave Connected");
 a40:	4e dd       	rcall	.-1380   	; 0x4de <lcd_clrscr>
 a42:	8d e1       	ldi	r24, 0x1D	; 29
 a44:	93 e0       	ldi	r25, 0x03	; 3
 a46:	60 dd       	rcall	.-1344   	; 0x508 <lcd_puts>
 a48:	2f ef       	ldi	r18, 0xFF	; 255
 a4a:	89 e6       	ldi	r24, 0x69	; 105
 a4c:	98 e1       	ldi	r25, 0x18	; 24
 a4e:	21 50       	subi	r18, 0x01	; 1
 a50:	80 40       	sbci	r24, 0x00	; 0
 a52:	90 40       	sbci	r25, 0x00	; 0
 a54:	e1 f7       	brne	.-8      	; 0xa4e <system_init+0xda>
 a56:	00 c0       	rjmp	.+0      	; 0xa58 <system_init+0xe4>
        _delay_ms(500);
    } else {
        lcd_clrscr();
 a58:	00 00       	nop
 a5a:	13 c0       	rjmp	.+38     	; 0xa82 <system_init+0x10e>
        lcd_puts("Slave Error!");
 a5c:	40 dd       	rcall	.-1408   	; 0x4de <lcd_clrscr>
 a5e:	8d e2       	ldi	r24, 0x2D	; 45
 a60:	93 e0       	ldi	r25, 0x03	; 3
 a62:	52 dd       	rcall	.-1372   	; 0x508 <lcd_puts>
        lcd_gotoxy(0, 1);
 a64:	61 e0       	ldi	r22, 0x01	; 1
 a66:	80 e0       	ldi	r24, 0x00	; 0
 a68:	32 dd       	rcall	.-1436   	; 0x4ce <lcd_gotoxy>
 a6a:	8a e3       	ldi	r24, 0x3A	; 58
        lcd_puts("Check connections");
 a6c:	93 e0       	ldi	r25, 0x03	; 3
 a6e:	4c dd       	rcall	.-1384   	; 0x508 <lcd_puts>
 a70:	2f ef       	ldi	r18, 0xFF	; 255
 a72:	87 ea       	ldi	r24, 0xA7	; 167
 a74:	91 e6       	ldi	r25, 0x61	; 97
 a76:	21 50       	subi	r18, 0x01	; 1
 a78:	80 40       	sbci	r24, 0x00	; 0
 a7a:	90 40       	sbci	r25, 0x00	; 0
 a7c:	e1 f7       	brne	.-8      	; 0xa76 <system_init+0x102>
 a7e:	00 c0       	rjmp	.+0      	; 0xa80 <system_init+0x10c>
 a80:	00 00       	nop
 a82:	80 e0       	ldi	r24, 0x00	; 0
 a84:	4f cf       	rjmp	.-354    	; 0x924 <set_state>
        _delay_ms(2000);
    }
    
    // Set initial state
    set_state(STATE_IDLE);
 a86:	08 95       	ret

00000a88 <process_keypad_input>:
 a88:	8f 3f       	cpi	r24, 0xFF	; 255
 a8a:	09 f4       	brne	.+2      	; 0xa8e <process_keypad_input+0x6>
 a8c:	de c0       	rjmp	.+444    	; 0xc4a <process_keypad_input+0x1c2>
// Process keypad input
void process_keypad_input(uint8_t key) {
    if (key == 0xFF) return;  // No key pressed
    
    // Visual feedback for key press
    DEBUG_LED_PORT |= (1 << DEBUG_LED_PIN);
 a8e:	95 b1       	in	r25, 0x05	; 5
 a90:	90 68       	ori	r25, 0x80	; 128
 a92:	95 b9       	out	0x05, r25	; 5
 a94:	2f ef       	ldi	r18, 0xFF	; 255
 a96:	30 e7       	ldi	r19, 0x70	; 112
 a98:	92 e0       	ldi	r25, 0x02	; 2
 a9a:	21 50       	subi	r18, 0x01	; 1
 a9c:	30 40       	sbci	r19, 0x00	; 0
 a9e:	90 40       	sbci	r25, 0x00	; 0
 aa0:	e1 f7       	brne	.-8      	; 0xa9a <process_keypad_input+0x12>
 aa2:	00 c0       	rjmp	.+0      	; 0xaa4 <process_keypad_input+0x1c>
 aa4:	00 00       	nop
    _delay_ms(50);
    DEBUG_LED_PORT &= ~(1 << DEBUG_LED_PIN);
 aa6:	95 b1       	in	r25, 0x05	; 5
 aa8:	9f 77       	andi	r25, 0x7F	; 127
 aaa:	95 b9       	out	0x05, r25	; 5
    
    // Handle different keys based on current state
    switch (current_state) {
 aac:	90 91 59 03 	lds	r25, 0x0359	; 0x800359 <current_state>
 ab0:	94 30       	cpi	r25, 0x04	; 4
 ab2:	09 f4       	brne	.+2      	; 0xab6 <process_keypad_input+0x2e>
 ab4:	55 c0       	rjmp	.+170    	; 0xb60 <process_keypad_input+0xd8>
 ab6:	96 30       	cpi	r25, 0x06	; 6
 ab8:	09 f4       	brne	.+2      	; 0xabc <process_keypad_input+0x34>
 aba:	be c0       	rjmp	.+380    	; 0xc38 <process_keypad_input+0x1b0>
 abc:	91 11       	cpse	r25, r1
 abe:	c5 c0       	rjmp	.+394    	; 0xc4a <process_keypad_input+0x1c2>
        case STATE_IDLE:
            // Process numeric keys (0-9)
            if ((key >= '0' && key <= '9') && input_index < 2) {
 ac0:	90 ed       	ldi	r25, 0xD0	; 208
 ac2:	98 0f       	add	r25, r24
 ac4:	9a 30       	cpi	r25, 0x0A	; 10
 ac6:	80 f4       	brcc	.+32     	; 0xae8 <process_keypad_input+0x60>
 ac8:	20 91 53 03 	lds	r18, 0x0353	; 0x800353 <input_index>
 acc:	22 30       	cpi	r18, 0x02	; 2
 ace:	60 f4       	brcc	.+24     	; 0xae8 <process_keypad_input+0x60>
                input_buffer[input_index++] = key - '0';
 ad0:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <input_index>
 ad4:	81 e0       	ldi	r24, 0x01	; 1
 ad6:	8e 0f       	add	r24, r30
 ad8:	80 93 53 03 	sts	0x0353, r24	; 0x800353 <input_index>
 adc:	f0 e0       	ldi	r31, 0x00	; 0
 ade:	ec 5a       	subi	r30, 0xAC	; 172
 ae0:	fc 4f       	sbci	r31, 0xFC	; 252
 ae2:	90 83       	st	Z, r25
                update_display();
 ae4:	59 ce       	rjmp	.-846    	; 0x798 <update_display>
 ae6:	08 95       	ret
            }
            // Process '*' key as confirm/enter
            else if (key == '*' && input_index > 0) {
 ae8:	8a 32       	cpi	r24, 0x2A	; 42
 aea:	a1 f5       	brne	.+104    	; 0xb54 <process_keypad_input+0xcc>
 aec:	90 91 53 03 	lds	r25, 0x0353	; 0x800353 <input_index>
 af0:	99 23       	and	r25, r25
                target_floor = convert_input_to_floor();
 af2:	81 f1       	breq	.+96     	; 0xb54 <process_keypad_input+0xcc>
 af4:	3b de       	rcall	.-906    	; 0x76c <convert_input_to_floor>
 af6:	80 93 57 03 	sts	0x0357, r24	; 0x800357 <target_floor>
                
                // Special case: 00 + * to enter maintenance mode
                if (target_floor == 0 && input_index == 2 && 
 afa:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <target_floor>
 afe:	81 11       	cpse	r24, r1
 b00:	13 c0       	rjmp	.+38     	; 0xb28 <process_keypad_input+0xa0>
 b02:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <input_index>
 b06:	82 30       	cpi	r24, 0x02	; 2
 b08:	79 f4       	brne	.+30     	; 0xb28 <process_keypad_input+0xa0>
                    input_buffer[0] == 0 && input_buffer[1] == 0) {
 b0a:	80 91 54 03 	lds	r24, 0x0354	; 0x800354 <input_buffer>
            // Process '*' key as confirm/enter
            else if (key == '*' && input_index > 0) {
                target_floor = convert_input_to_floor();
                
                // Special case: 00 + * to enter maintenance mode
                if (target_floor == 0 && input_index == 2 && 
 b0e:	81 11       	cpse	r24, r1
 b10:	0b c0       	rjmp	.+22     	; 0xb28 <process_keypad_input+0xa0>
                    input_buffer[0] == 0 && input_buffer[1] == 0) {
 b12:	80 91 55 03 	lds	r24, 0x0355	; 0x800355 <input_buffer+0x1>
 b16:	81 11       	cpse	r24, r1
 b18:	07 c0       	rjmp	.+14     	; 0xb28 <process_keypad_input+0xa0>
                    maintenance_mode = 1;
 b1a:	81 e0       	ldi	r24, 0x01	; 1
 b1c:	80 93 4e 03 	sts	0x034E, r24	; 0x80034e <maintenance_mode>
                    set_state(STATE_MAINTENANCE);
 b20:	86 e0       	ldi	r24, 0x06	; 6
                    clear_input_buffer();
 b22:	00 df       	rcall	.-512    	; 0x924 <set_state>
 b24:	16 ce       	rjmp	.-980    	; 0x752 <clear_input_buffer>
                    return;
 b26:	08 95       	ret
                }
                
                // Check if target floor is the same as current floor (fault)
                if (target_floor == current_floor) {
 b28:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <target_floor>
 b2c:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
 b30:	98 13       	cpse	r25, r24
                    set_state(STATE_FAULT);
 b32:	03 c0       	rjmp	.+6      	; 0xb3a <process_keypad_input+0xb2>
 b34:	85 e0       	ldi	r24, 0x05	; 5
 b36:	f6 de       	rcall	.-532    	; 0x924 <set_state>
 b38:	0b c0       	rjmp	.+22     	; 0xb50 <process_keypad_input+0xc8>
                }
                // Otherwise, start moving to target floor
                else if (target_floor > current_floor) {
 b3a:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <target_floor>
 b3e:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
 b42:	89 17       	cp	r24, r25
                    set_state(STATE_MOVING_UP);
 b44:	18 f4       	brcc	.+6      	; 0xb4c <process_keypad_input+0xc4>
 b46:	81 e0       	ldi	r24, 0x01	; 1
 b48:	ed de       	rcall	.-550    	; 0x924 <set_state>
                }
                else {
                    set_state(STATE_MOVING_DOWN);
 b4a:	02 c0       	rjmp	.+4      	; 0xb50 <process_keypad_input+0xc8>
 b4c:	82 e0       	ldi	r24, 0x02	; 2
                }
                
                // Clear input buffer
                clear_input_buffer();
 b4e:	ea de       	rcall	.-556    	; 0x924 <set_state>
 b50:	00 ce       	rjmp	.-1024   	; 0x752 <clear_input_buffer>
 b52:	08 95       	ret
            }
            // Process '#' key as clear
            else if (key == '#') {
 b54:	83 32       	cpi	r24, 0x23	; 35
 b56:	09 f0       	breq	.+2      	; 0xb5a <process_keypad_input+0xd2>
 b58:	78 c0       	rjmp	.+240    	; 0xc4a <process_keypad_input+0x1c2>
                clear_input_buffer();
 b5a:	fb dd       	rcall	.-1034   	; 0x752 <clear_input_buffer>
 b5c:	1d ce       	rjmp	.-966    	; 0x798 <update_display>
                update_display();
 b5e:	08 95       	ret
 b60:	8a 32       	cpi	r24, 0x2A	; 42
 b62:	49 f5       	brne	.+82     	; 0xbb6 <process_keypad_input+0x12e>
            }
            break;
            
        case STATE_EMERGENCY:
            // In emergency state, '*' button opens door and starts melody
            if (key == '*' && !door_open) {
 b64:	90 91 51 03 	lds	r25, 0x0351	; 0x800351 <door_open>
 b68:	91 11       	cpse	r25, r1
 b6a:	25 c0       	rjmp	.+74     	; 0xbb6 <process_keypad_input+0x12e>
 b6c:	81 e0       	ldi	r24, 0x01	; 1
                door_open = 1;
 b6e:	80 93 51 03 	sts	0x0351, r24	; 0x800351 <door_open>
 b72:	80 93 50 03 	sts	0x0350, r24	; 0x800350 <melody_playing>
                melody_playing = 1;
 b76:	61 e0       	ldi	r22, 0x01	; 1
                
                // Explicitly send door open command multiple times for reliability
                TWI_send_command_safe(CMD_DOOR_OPEN, 1);
 b78:	83 e0       	ldi	r24, 0x03	; 3
 b7a:	82 dd       	rcall	.-1276   	; 0x680 <TWI_send_command_safe>
 b7c:	2f ef       	ldi	r18, 0xFF	; 255
 b7e:	31 ee       	ldi	r19, 0xE1	; 225
 b80:	84 e0       	ldi	r24, 0x04	; 4
 b82:	21 50       	subi	r18, 0x01	; 1
 b84:	30 40       	sbci	r19, 0x00	; 0
 b86:	80 40       	sbci	r24, 0x00	; 0
 b88:	e1 f7       	brne	.-8      	; 0xb82 <process_keypad_input+0xfa>
 b8a:	00 c0       	rjmp	.+0      	; 0xb8c <process_keypad_input+0x104>
 b8c:	00 00       	nop
 b8e:	61 e0       	ldi	r22, 0x01	; 1
                _delay_ms(100);
                TWI_send_command_safe(CMD_DOOR_OPEN, 1);
 b90:	83 e0       	ldi	r24, 0x03	; 3
 b92:	76 dd       	rcall	.-1300   	; 0x680 <TWI_send_command_safe>
 b94:	9f ef       	ldi	r25, 0xFF	; 255
 b96:	21 ee       	ldi	r18, 0xE1	; 225
 b98:	34 e0       	ldi	r19, 0x04	; 4
 b9a:	91 50       	subi	r25, 0x01	; 1
 b9c:	20 40       	sbci	r18, 0x00	; 0
 b9e:	30 40       	sbci	r19, 0x00	; 0
 ba0:	e1 f7       	brne	.-8      	; 0xb9a <process_keypad_input+0x112>
 ba2:	00 c0       	rjmp	.+0      	; 0xba4 <process_keypad_input+0x11c>
                _delay_ms(100);
                TWI_send_command_safe(CMD_DOOR_OPEN, 1);
 ba4:	00 00       	nop
 ba6:	61 e0       	ldi	r22, 0x01	; 1
 ba8:	83 e0       	ldi	r24, 0x03	; 3
 baa:	6a dd       	rcall	.-1324   	; 0x680 <TWI_send_command_safe>
                
                // Start the melody
                TWI_send_command_safe(CMD_PLAY_MELODY, 1);
 bac:	61 e0       	ldi	r22, 0x01	; 1
 bae:	87 e0       	ldi	r24, 0x07	; 7
 bb0:	67 dd       	rcall	.-1330   	; 0x680 <TWI_send_command_safe>
                
                update_display();
 bb2:	f2 cd       	rjmp	.-1052   	; 0x798 <update_display>
 bb4:	08 95       	ret
 bb6:	83 32       	cpi	r24, 0x23	; 35
            }
            // '#' button stops melody and closes door
            else if (key == '#' && door_open) {
 bb8:	09 f0       	breq	.+2      	; 0xbbc <process_keypad_input+0x134>
 bba:	47 c0       	rjmp	.+142    	; 0xc4a <process_keypad_input+0x1c2>
 bbc:	80 91 51 03 	lds	r24, 0x0351	; 0x800351 <door_open>
 bc0:	88 23       	and	r24, r24
 bc2:	09 f4       	brne	.+2      	; 0xbc6 <process_keypad_input+0x13e>
 bc4:	42 c0       	rjmp	.+132    	; 0xc4a <process_keypad_input+0x1c2>
                // Stop melody and close door
                TWI_send_command_safe(CMD_STOP_MELODY, 0);
 bc6:	60 e0       	ldi	r22, 0x00	; 0
 bc8:	88 e0       	ldi	r24, 0x08	; 8
 bca:	5a dd       	rcall	.-1356   	; 0x680 <TWI_send_command_safe>
 bcc:	8f ef       	ldi	r24, 0xFF	; 255
 bce:	99 e6       	ldi	r25, 0x69	; 105
 bd0:	28 e1       	ldi	r18, 0x18	; 24
 bd2:	81 50       	subi	r24, 0x01	; 1
 bd4:	90 40       	sbci	r25, 0x00	; 0
 bd6:	20 40       	sbci	r18, 0x00	; 0
 bd8:	e1 f7       	brne	.-8      	; 0xbd2 <process_keypad_input+0x14a>
 bda:	00 c0       	rjmp	.+0      	; 0xbdc <process_keypad_input+0x154>
 bdc:	00 00       	nop
                _delay_ms(500);
                
                // Send door close command multiple times for reliability
                TWI_send_command_safe(CMD_DOOR_CLOSE, 0);
 bde:	60 e0       	ldi	r22, 0x00	; 0
 be0:	84 e0       	ldi	r24, 0x04	; 4
 be2:	4e dd       	rcall	.-1380   	; 0x680 <TWI_send_command_safe>
 be4:	3f ef       	ldi	r19, 0xFF	; 255
 be6:	81 ee       	ldi	r24, 0xE1	; 225
 be8:	94 e0       	ldi	r25, 0x04	; 4
 bea:	31 50       	subi	r19, 0x01	; 1
 bec:	80 40       	sbci	r24, 0x00	; 0
 bee:	90 40       	sbci	r25, 0x00	; 0
 bf0:	e1 f7       	brne	.-8      	; 0xbea <process_keypad_input+0x162>
 bf2:	00 c0       	rjmp	.+0      	; 0xbf4 <process_keypad_input+0x16c>
 bf4:	00 00       	nop
                _delay_ms(100);
                TWI_send_command_safe(CMD_DOOR_CLOSE, 0);
 bf6:	60 e0       	ldi	r22, 0x00	; 0
 bf8:	84 e0       	ldi	r24, 0x04	; 4
 bfa:	42 dd       	rcall	.-1404   	; 0x680 <TWI_send_command_safe>
 bfc:	2f ef       	ldi	r18, 0xFF	; 255
 bfe:	31 ee       	ldi	r19, 0xE1	; 225
 c00:	84 e0       	ldi	r24, 0x04	; 4
 c02:	21 50       	subi	r18, 0x01	; 1
 c04:	30 40       	sbci	r19, 0x00	; 0
 c06:	80 40       	sbci	r24, 0x00	; 0
 c08:	e1 f7       	brne	.-8      	; 0xc02 <process_keypad_input+0x17a>
 c0a:	00 c0       	rjmp	.+0      	; 0xc0c <process_keypad_input+0x184>
 c0c:	00 00       	nop
 c0e:	60 e0       	ldi	r22, 0x00	; 0
                _delay_ms(100);
                TWI_send_command_safe(CMD_DOOR_CLOSE, 0);
 c10:	84 e0       	ldi	r24, 0x04	; 4
 c12:	36 dd       	rcall	.-1428   	; 0x680 <TWI_send_command_safe>
 c14:	10 92 51 03 	sts	0x0351, r1	; 0x800351 <door_open>
                
                door_open = 0;
 c18:	10 92 50 03 	sts	0x0350, r1	; 0x800350 <melody_playing>
                melody_playing = 0;
 c1c:	9f ef       	ldi	r25, 0xFF	; 255
 c1e:	23 ed       	ldi	r18, 0xD3	; 211
 c20:	30 e3       	ldi	r19, 0x30	; 48
 c22:	91 50       	subi	r25, 0x01	; 1
 c24:	20 40       	sbci	r18, 0x00	; 0
 c26:	30 40       	sbci	r19, 0x00	; 0
 c28:	e1 f7       	brne	.-8      	; 0xc22 <process_keypad_input+0x19a>
 c2a:	00 c0       	rjmp	.+0      	; 0xc2c <process_keypad_input+0x1a4>
                
                // Return to idle state
                _delay_ms(1000);
                emergency_flag = 0;
 c2c:	00 00       	nop
 c2e:	10 92 52 03 	sts	0x0352, r1	; 0x800352 <emergency_flag>
                set_state(STATE_IDLE);
 c32:	80 e0       	ldi	r24, 0x00	; 0
 c34:	77 ce       	rjmp	.-786    	; 0x924 <set_state>
 c36:	08 95       	ret
            }
            break;
            
        case STATE_MAINTENANCE:
            // Exit maintenance mode when '*' is pressed
            if (key == '*') {
 c38:	8a 32       	cpi	r24, 0x2A	; 42
 c3a:	39 f4       	brne	.+14     	; 0xc4a <process_keypad_input+0x1c2>
                maintenance_mode = 0;
 c3c:	10 92 4e 03 	sts	0x034E, r1	; 0x80034e <maintenance_mode>
                TWI_send_command_safe(CMD_IDLE, 0);  // Return slave to idle state
 c40:	60 e0       	ldi	r22, 0x00	; 0
 c42:	80 e0       	ldi	r24, 0x00	; 0
 c44:	1d dd       	rcall	.-1478   	; 0x680 <TWI_send_command_safe>
 c46:	80 e0       	ldi	r24, 0x00	; 0
                set_state(STATE_IDLE);
 c48:	6d ce       	rjmp	.-806    	; 0x924 <set_state>
 c4a:	08 95       	ret

00000c4c <handle_emergency>:
 c4c:	84 e0       	ldi	r24, 0x04	; 4
 c4e:	6a de       	rcall	.-812    	; 0x924 <set_state>
void handle_emergency(void) {
    // Change to emergency state
    set_state(STATE_EMERGENCY);
    
    // Send emergency command to slave to blink movement LED
    TWI_send_command_safe(CMD_EMERGENCY, 0);
 c50:	60 e0       	ldi	r22, 0x00	; 0
 c52:	85 e0       	ldi	r24, 0x05	; 5
 c54:	15 dd       	rcall	.-1494   	; 0x680 <TWI_send_command_safe>
 c56:	2f ef       	ldi	r18, 0xFF	; 255
 c58:	81 ee       	ldi	r24, 0xE1	; 225
 c5a:	94 e0       	ldi	r25, 0x04	; 4
 c5c:	21 50       	subi	r18, 0x01	; 1
 c5e:	80 40       	sbci	r24, 0x00	; 0
 c60:	90 40       	sbci	r25, 0x00	; 0
 c62:	e1 f7       	brne	.-8      	; 0xc5c <handle_emergency+0x10>
 c64:	00 c0       	rjmp	.+0      	; 0xc66 <handle_emergency+0x1a>
 c66:	00 00       	nop
    _delay_ms(100);
    TWI_send_command_safe(CMD_EMERGENCY, 0);  // Send twice for reliability
 c68:	60 e0       	ldi	r22, 0x00	; 0
 c6a:	85 e0       	ldi	r24, 0x05	; 5
 c6c:	09 dd       	rcall	.-1518   	; 0x680 <TWI_send_command_safe>
    
    // Reset door and melody flags
    door_open = 0;
 c6e:	10 92 51 03 	sts	0x0351, r1	; 0x800351 <door_open>
    melody_playing = 0;
 c72:	10 92 50 03 	sts	0x0350, r1	; 0x800350 <melody_playing>
    
    // Update display to show emergency message
    update_display();
 c76:	90 cd       	rjmp	.-1248   	; 0x798 <update_display>
 c78:	08 95       	ret

00000c7a <check_for_obstruction>:
    // Update the display with maintenance message
    update_display();
}

// Check for obstruction using ultrasonic sensor
void check_for_obstruction(void) {
 c7a:	cf 93       	push	r28
    // Only check for obstructions when elevator is moving
    if (current_state == STATE_MOVING_UP || current_state == STATE_MOVING_DOWN) {
 c7c:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
 c80:	81 30       	cpi	r24, 0x01	; 1
 c82:	21 f0       	breq	.+8      	; 0xc8c <check_for_obstruction+0x12>
 c84:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
 c88:	82 30       	cpi	r24, 0x02	; 2
 c8a:	11 f5       	brne	.+68     	; 0xcd0 <check_for_obstruction+0x56>
        // Get distance from ultrasonic sensor
        distance_cm = TWI_get_distance();
 c8c:	d6 dc       	rcall	.-1620   	; 0x63a <TWI_get_distance>
 c8e:	90 93 4d 03 	sts	0x034D, r25	; 0x80034d <__data_end+0x1>
 c92:	80 93 4c 03 	sts	0x034C, r24	; 0x80034c <__data_end>
        
        // Check if distance is less than 20 cm (obstruction detected)
        if (distance_cm < 20 && distance_cm > 0) {  // Also check for valid readings
 c96:	80 91 4c 03 	lds	r24, 0x034C	; 0x80034c <__data_end>
 c9a:	90 91 4d 03 	lds	r25, 0x034D	; 0x80034d <__data_end+0x1>
 c9e:	44 97       	sbiw	r24, 0x14	; 20
 ca0:	b8 f4       	brcc	.+46     	; 0xcd0 <check_for_obstruction+0x56>
 ca2:	80 91 4c 03 	lds	r24, 0x034C	; 0x80034c <__data_end>
 ca6:	90 91 4d 03 	lds	r25, 0x034D	; 0x80034d <__data_end+0x1>
 caa:	89 2b       	or	r24, r25
 cac:	89 f0       	breq	.+34     	; 0xcd0 <check_for_obstruction+0x56>
            // Store the previous state to return to it after obstruction is cleared
            ElevatorState prev_state = current_state;
 cae:	c0 91 59 03 	lds	r28, 0x0359	; 0x800359 <current_state>
            
            // Set state to obstruction
            set_state(STATE_OBSTRUCTION);
 cb2:	87 e0       	ldi	r24, 0x07	; 7
            
            // Update display
            update_display();
 cb4:	37 de       	rcall	.-914    	; 0x924 <set_state>
 cb6:	70 dd       	rcall	.-1312   	; 0x798 <update_display>
 cb8:	2f ef       	ldi	r18, 0xFF	; 255
 cba:	8b e7       	ldi	r24, 0x7B	; 123
 cbc:	92 e9       	ldi	r25, 0x92	; 146
 cbe:	21 50       	subi	r18, 0x01	; 1
 cc0:	80 40       	sbci	r24, 0x00	; 0
 cc2:	90 40       	sbci	r25, 0x00	; 0
 cc4:	e1 f7       	brne	.-8      	; 0xcbe <check_for_obstruction+0x44>
 cc6:	00 c0       	rjmp	.+0      	; 0xcc8 <check_for_obstruction+0x4e>
            
            // Wait for 3 seconds
            _delay_ms(3000);
            
            // Resume previous operation
            set_state(prev_state);
 cc8:	00 00       	nop
 cca:	8c 2f       	mov	r24, r28
 ccc:	2b de       	rcall	.-938    	; 0x924 <set_state>
            update_display();
 cce:	64 dd       	rcall	.-1336   	; 0x798 <update_display>
 cd0:	cf 91       	pop	r28
        }
    }
}
 cd2:	08 95       	ret

00000cd4 <move_elevator>:
 cd4:	cf 93       	push	r28
            break;
    }
}

// Move elevator to target floor
void move_elevator(void) {
 cd6:	df 93       	push	r29
 cd8:	00 d0       	rcall	.+0      	; 0xcda <move_elevator+0x6>
 cda:	1f 92       	push	r1
 cdc:	1f 92       	push	r1
 cde:	cd b7       	in	r28, 0x3d	; 61
 ce0:	de b7       	in	r29, 0x3e	; 62
    // Check for obstruction first
    check_for_obstruction();
 ce2:	cb df       	rcall	.-106    	; 0xc7a <check_for_obstruction>
    
    // Check emergency button - UPDATED FOR PIN 12
    if (is_emergency_button_pressed()) {
 ce4:	68 dc       	rcall	.-1840   	; 0x5b6 <is_emergency_button_pressed>
 ce6:	88 23       	and	r24, r24
 ce8:	31 f0       	breq	.+12     	; 0xcf6 <move_elevator+0x22>
 cea:	81 e0       	ldi	r24, 0x01	; 1
        emergency_flag = 1;
 cec:	80 93 52 03 	sts	0x0352, r24	; 0x800352 <emergency_flag>
 cf0:	85 b1       	in	r24, 0x05	; 5
        DEBUG_LED_PORT |= (1 << DEBUG_LED_PIN);  // Visual feedback
 cf2:	80 68       	ori	r24, 0x80	; 128
 cf4:	85 b9       	out	0x05, r24	; 5
 cf6:	80 91 52 03 	lds	r24, 0x0352	; 0x800352 <emergency_flag>
    }
    
    // Check if emergency has been triggered
    if (emergency_flag) {
 cfa:	88 23       	and	r24, r24
 cfc:	11 f0       	breq	.+4      	; 0xd02 <move_elevator+0x2e>
        handle_emergency();
 cfe:	a6 df       	rcall	.-180    	; 0xc4c <handle_emergency>
 d00:	c1 c0       	rjmp	.+386    	; 0xe84 <move_elevator+0x1b0>
        return;
 d02:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
    }
    
    // If in obstruction state, do nothing until timeout
    if (current_state == STATE_OBSTRUCTION) {
 d06:	87 30       	cpi	r24, 0x07	; 7
 d08:	09 f4       	brne	.+2      	; 0xd0c <move_elevator+0x38>
 d0a:	bc c0       	rjmp	.+376    	; 0xe84 <move_elevator+0x1b0>
 d0c:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
        return;
    }
    
    // Simulate elevator movement by incrementing/decrementing floor
    if (current_state == STATE_MOVING_UP && current_floor < target_floor) {
 d10:	81 30       	cpi	r24, 0x01	; 1
 d12:	a1 f5       	brne	.+104    	; 0xd7c <move_elevator+0xa8>
 d14:	90 91 58 03 	lds	r25, 0x0358	; 0x800358 <current_floor>
 d18:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <target_floor>
 d1c:	98 17       	cp	r25, r24
 d1e:	70 f5       	brcc	.+92     	; 0xd7c <move_elevator+0xa8>
 d20:	2f ef       	ldi	r18, 0xFF	; 255
 d22:	83 ed       	ldi	r24, 0xD3	; 211
 d24:	90 e3       	ldi	r25, 0x30	; 48
 d26:	21 50       	subi	r18, 0x01	; 1
 d28:	80 40       	sbci	r24, 0x00	; 0
 d2a:	90 40       	sbci	r25, 0x00	; 0
 d2c:	e1 f7       	brne	.-8      	; 0xd26 <move_elevator+0x52>
 d2e:	00 c0       	rjmp	.+0      	; 0xd30 <move_elevator+0x5c>
 d30:	00 00       	nop
 d32:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
        _delay_ms(1000);  // Delay to simulate movement time
        current_floor++;
 d36:	8f 5f       	subi	r24, 0xFF	; 255
 d38:	80 93 58 03 	sts	0x0358, r24	; 0x800358 <current_floor>
        
        // Check for obstruction again after moving
        check_for_obstruction();
 d3c:	9e df       	rcall	.-196    	; 0xc7a <check_for_obstruction>
 d3e:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
        if (current_state == STATE_OBSTRUCTION) {
 d42:	87 30       	cpi	r24, 0x07	; 7
 d44:	09 f4       	brne	.+2      	; 0xd48 <move_elevator+0x74>
 d46:	9e c0       	rjmp	.+316    	; 0xe84 <move_elevator+0x1b0>
            return;
        }
        
        // Explicitly update display with current floor - direct LCD update
        lcd_clrscr();
 d48:	ca db       	rcall	.-2156   	; 0x4de <lcd_clrscr>
 d4a:	83 e2       	ldi	r24, 0x23	; 35
        lcd_puts("Going up");
 d4c:	92 e0       	ldi	r25, 0x02	; 2
 d4e:	dc db       	rcall	.-2120   	; 0x508 <lcd_puts>
 d50:	61 e0       	ldi	r22, 0x01	; 1
        lcd_gotoxy(0, 1);
 d52:	80 e0       	ldi	r24, 0x00	; 0
 d54:	bc db       	rcall	.-2184   	; 0x4ce <lcd_gotoxy>
 d56:	8c e2       	ldi	r24, 0x2C	; 44
 d58:	92 e0       	ldi	r25, 0x02	; 2
        lcd_puts("Floor: ");
 d5a:	d6 db       	rcall	.-2132   	; 0x508 <lcd_puts>
 d5c:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
        char up_buffer[5];
        itoa(current_floor, up_buffer, 10);
 d60:	4a e0       	ldi	r20, 0x0A	; 10
 d62:	be 01       	movw	r22, r28
 d64:	6f 5f       	subi	r22, 0xFF	; 255
 d66:	7f 4f       	sbci	r23, 0xFF	; 255
 d68:	90 e0       	ldi	r25, 0x00	; 0
 d6a:	ce d0       	rcall	.+412    	; 0xf08 <__itoa_ncheck>
 d6c:	ce 01       	movw	r24, r28
        lcd_puts(up_buffer);
 d6e:	01 96       	adiw	r24, 0x01	; 1
 d70:	cb db       	rcall	.-2154   	; 0x508 <lcd_puts>
 d72:	60 91 58 03 	lds	r22, 0x0358	; 0x800358 <current_floor>
        
        // Notify slave about current floor
        TWI_send_command_safe(CMD_MOVING_UP, current_floor);
 d76:	81 e0       	ldi	r24, 0x01	; 1
 d78:	83 dc       	rcall	.-1786   	; 0x680 <TWI_send_command_safe>
 d7a:	37 c0       	rjmp	.+110    	; 0xdea <move_elevator+0x116>
 d7c:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
    if (current_state == STATE_OBSTRUCTION) {
        return;
    }
    
    // Simulate elevator movement by incrementing/decrementing floor
    if (current_state == STATE_MOVING_UP && current_floor < target_floor) {
 d80:	82 30       	cpi	r24, 0x02	; 2
        lcd_puts(up_buffer);
        
        // Notify slave about current floor
        TWI_send_command_safe(CMD_MOVING_UP, current_floor);
    }
    else if (current_state == STATE_MOVING_DOWN && current_floor > target_floor) {
 d82:	99 f5       	brne	.+102    	; 0xdea <move_elevator+0x116>
 d84:	90 91 58 03 	lds	r25, 0x0358	; 0x800358 <current_floor>
 d88:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <target_floor>
 d8c:	89 17       	cp	r24, r25
 d8e:	68 f5       	brcc	.+90     	; 0xdea <move_elevator+0x116>
 d90:	2f ef       	ldi	r18, 0xFF	; 255
 d92:	83 ed       	ldi	r24, 0xD3	; 211
 d94:	90 e3       	ldi	r25, 0x30	; 48
 d96:	21 50       	subi	r18, 0x01	; 1
 d98:	80 40       	sbci	r24, 0x00	; 0
 d9a:	90 40       	sbci	r25, 0x00	; 0
 d9c:	e1 f7       	brne	.-8      	; 0xd96 <move_elevator+0xc2>
 d9e:	00 c0       	rjmp	.+0      	; 0xda0 <move_elevator+0xcc>
 da0:	00 00       	nop
 da2:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
        _delay_ms(1000);  // Delay to simulate movement time
        current_floor--;
 da6:	81 50       	subi	r24, 0x01	; 1
 da8:	80 93 58 03 	sts	0x0358, r24	; 0x800358 <current_floor>
        
        // Check for obstruction again after moving
        check_for_obstruction();
 dac:	66 df       	rcall	.-308    	; 0xc7a <check_for_obstruction>
        if (current_state == STATE_OBSTRUCTION) {
 dae:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
 db2:	87 30       	cpi	r24, 0x07	; 7
 db4:	09 f4       	brne	.+2      	; 0xdb8 <move_elevator+0xe4>
            return;
        }
        
        // Explicitly update display with current floor - direct LCD update
        lcd_clrscr();
 db6:	66 c0       	rjmp	.+204    	; 0xe84 <move_elevator+0x1b0>
 db8:	92 db       	rcall	.-2268   	; 0x4de <lcd_clrscr>
        lcd_puts("Going down");
 dba:	84 e3       	ldi	r24, 0x34	; 52
 dbc:	92 e0       	ldi	r25, 0x02	; 2
 dbe:	a4 db       	rcall	.-2232   	; 0x508 <lcd_puts>
        lcd_gotoxy(0, 1);
 dc0:	61 e0       	ldi	r22, 0x01	; 1
 dc2:	80 e0       	ldi	r24, 0x00	; 0
 dc4:	84 db       	rcall	.-2296   	; 0x4ce <lcd_gotoxy>
        lcd_puts("Floor: ");
 dc6:	8c e2       	ldi	r24, 0x2C	; 44
 dc8:	92 e0       	ldi	r25, 0x02	; 2
 dca:	9e db       	rcall	.-2244   	; 0x508 <lcd_puts>
        char down_buffer[5];
        itoa(current_floor, down_buffer, 10);
 dcc:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <current_floor>
 dd0:	4a e0       	ldi	r20, 0x0A	; 10
 dd2:	be 01       	movw	r22, r28
 dd4:	6f 5f       	subi	r22, 0xFF	; 255
 dd6:	7f 4f       	sbci	r23, 0xFF	; 255
 dd8:	90 e0       	ldi	r25, 0x00	; 0
 dda:	96 d0       	rcall	.+300    	; 0xf08 <__itoa_ncheck>
        lcd_puts(down_buffer);
 ddc:	ce 01       	movw	r24, r28
 dde:	01 96       	adiw	r24, 0x01	; 1
 de0:	93 db       	rcall	.-2266   	; 0x508 <lcd_puts>
        
        // Notify slave about current floor
        TWI_send_command_safe(CMD_MOVING_DOWN, current_floor);
 de2:	60 91 58 03 	lds	r22, 0x0358	; 0x800358 <current_floor>
 de6:	82 e0       	ldi	r24, 0x02	; 2
 de8:	4b dc       	rcall	.-1898   	; 0x680 <TWI_send_command_safe>
    }
    
    // Check if reached target floor
    if (current_floor == target_floor) {
 dea:	90 91 58 03 	lds	r25, 0x0358	; 0x800358 <current_floor>
 dee:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <target_floor>
 df2:	98 13       	cpse	r25, r24
 df4:	47 c0       	rjmp	.+142    	; 0xe84 <move_elevator+0x1b0>
        // Tell slave we've reached the floor
        TWI_send_command_safe(CMD_FLOOR_REACHED, current_floor);
 df6:	60 91 58 03 	lds	r22, 0x0358	; 0x800358 <current_floor>
 dfa:	89 e0       	ldi	r24, 0x09	; 9
 dfc:	41 dc       	rcall	.-1918   	; 0x680 <TWI_send_command_safe>
        
        // Change to door open state
        set_state(STATE_DOOR_OPEN);
 dfe:	83 e0       	ldi	r24, 0x03	; 3
 e00:	91 dd       	rcall	.-1246   	; 0x924 <set_state>
 e02:	61 e0       	ldi	r22, 0x01	; 1
        
        // Open door - send command multiple times for reliability
        TWI_send_command_safe(CMD_DOOR_OPEN, 1);
 e04:	83 e0       	ldi	r24, 0x03	; 3
 e06:	3c dc       	rcall	.-1928   	; 0x680 <TWI_send_command_safe>
 e08:	2f ef       	ldi	r18, 0xFF	; 255
 e0a:	81 ee       	ldi	r24, 0xE1	; 225
 e0c:	94 e0       	ldi	r25, 0x04	; 4
 e0e:	21 50       	subi	r18, 0x01	; 1
 e10:	80 40       	sbci	r24, 0x00	; 0
 e12:	90 40       	sbci	r25, 0x00	; 0
 e14:	e1 f7       	brne	.-8      	; 0xe0e <move_elevator+0x13a>
 e16:	00 c0       	rjmp	.+0      	; 0xe18 <move_elevator+0x144>
 e18:	00 00       	nop
 e1a:	61 e0       	ldi	r22, 0x01	; 1
        _delay_ms(100);
        TWI_send_command_safe(CMD_DOOR_OPEN, 1);
 e1c:	83 e0       	ldi	r24, 0x03	; 3
 e1e:	30 dc       	rcall	.-1952   	; 0x680 <TWI_send_command_safe>
 e20:	2f ef       	ldi	r18, 0xFF	; 255
 e22:	81 ee       	ldi	r24, 0xE1	; 225
 e24:	94 e0       	ldi	r25, 0x04	; 4
 e26:	21 50       	subi	r18, 0x01	; 1
 e28:	80 40       	sbci	r24, 0x00	; 0
 e2a:	90 40       	sbci	r25, 0x00	; 0
 e2c:	e1 f7       	brne	.-8      	; 0xe26 <move_elevator+0x152>
 e2e:	00 c0       	rjmp	.+0      	; 0xe30 <move_elevator+0x15c>
 e30:	00 00       	nop
 e32:	61 e0       	ldi	r22, 0x01	; 1
        _delay_ms(100);
        TWI_send_command_safe(CMD_DOOR_OPEN, 1);
 e34:	83 e0       	ldi	r24, 0x03	; 3
 e36:	24 dc       	rcall	.-1976   	; 0x680 <TWI_send_command_safe>
 e38:	2f ef       	ldi	r18, 0xFF	; 255
 e3a:	83 e2       	ldi	r24, 0x23	; 35
 e3c:	94 ef       	ldi	r25, 0xF4	; 244
 e3e:	21 50       	subi	r18, 0x01	; 1
 e40:	80 40       	sbci	r24, 0x00	; 0
 e42:	90 40       	sbci	r25, 0x00	; 0
 e44:	e1 f7       	brne	.-8      	; 0xe3e <move_elevator+0x16a>
 e46:	00 c0       	rjmp	.+0      	; 0xe48 <move_elevator+0x174>
 e48:	00 00       	nop
 e4a:	60 e0       	ldi	r22, 0x00	; 0
        
        // Keep door open for 5 seconds
        _delay_ms(5000);
        
        // Close door and return to idle
        TWI_send_command_safe(CMD_DOOR_CLOSE, 0);
 e4c:	84 e0       	ldi	r24, 0x04	; 4
 e4e:	18 dc       	rcall	.-2000   	; 0x680 <TWI_send_command_safe>
 e50:	2f ef       	ldi	r18, 0xFF	; 255
 e52:	81 ee       	ldi	r24, 0xE1	; 225
 e54:	94 e0       	ldi	r25, 0x04	; 4
 e56:	21 50       	subi	r18, 0x01	; 1
 e58:	80 40       	sbci	r24, 0x00	; 0
 e5a:	90 40       	sbci	r25, 0x00	; 0
 e5c:	e1 f7       	brne	.-8      	; 0xe56 <move_elevator+0x182>
 e5e:	00 c0       	rjmp	.+0      	; 0xe60 <move_elevator+0x18c>
 e60:	00 00       	nop
        _delay_ms(100);
        TWI_send_command_safe(CMD_DOOR_CLOSE, 0);
 e62:	60 e0       	ldi	r22, 0x00	; 0
 e64:	84 e0       	ldi	r24, 0x04	; 4
 e66:	0c dc       	rcall	.-2024   	; 0x680 <TWI_send_command_safe>
 e68:	2f ef       	ldi	r18, 0xFF	; 255
 e6a:	81 ee       	ldi	r24, 0xE1	; 225
 e6c:	94 e0       	ldi	r25, 0x04	; 4
 e6e:	21 50       	subi	r18, 0x01	; 1
 e70:	80 40       	sbci	r24, 0x00	; 0
 e72:	90 40       	sbci	r25, 0x00	; 0
 e74:	e1 f7       	brne	.-8      	; 0xe6e <move_elevator+0x19a>
 e76:	00 c0       	rjmp	.+0      	; 0xe78 <move_elevator+0x1a4>
 e78:	00 00       	nop
 e7a:	60 e0       	ldi	r22, 0x00	; 0
        _delay_ms(100);
        TWI_send_command_safe(CMD_DOOR_CLOSE, 0);
 e7c:	84 e0       	ldi	r24, 0x04	; 4
 e7e:	00 dc       	rcall	.-2048   	; 0x680 <TWI_send_command_safe>
 e80:	80 e0       	ldi	r24, 0x00	; 0
 e82:	50 dd       	rcall	.-1376   	; 0x924 <set_state>
        
        set_state(STATE_IDLE);
 e84:	0f 90       	pop	r0
 e86:	0f 90       	pop	r0
 e88:	0f 90       	pop	r0
    }
}
 e8a:	0f 90       	pop	r0
 e8c:	0f 90       	pop	r0
 e8e:	df 91       	pop	r29
 e90:	cf 91       	pop	r28
 e92:	08 95       	ret

00000e94 <main>:
 e94:	6f dd       	rcall	.-1314   	; 0x974 <system_init>
 e96:	10 92 52 03 	sts	0x0352, r1	; 0x800352 <emergency_flag>
    // EXPLICITLY reset emergency flag after initialization
    emergency_flag = 0;
    
    while (1) {
        // Check if in maintenance mode
        if (current_state == STATE_MAINTENANCE) {
 e9a:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
 e9e:	86 30       	cpi	r24, 0x06	; 6
            handle_maintenance_mode();
 ea0:	11 f4       	brne	.+4      	; 0xea6 <main+0x12>
 ea2:	3b dd       	rcall	.-1418   	; 0x91a <handle_maintenance_mode>
 ea4:	0a c0       	rjmp	.+20     	; 0xeba <main+0x26>
        }
        // Handle elevator movement if in moving state - first priority
        else if (current_state == STATE_MOVING_UP || current_state == STATE_MOVING_DOWN) {
 ea6:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
 eaa:	81 30       	cpi	r24, 0x01	; 1
 eac:	21 f0       	breq	.+8      	; 0xeb6 <main+0x22>
 eae:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
 eb2:	82 30       	cpi	r24, 0x02	; 2
            move_elevator();
 eb4:	11 f4       	brne	.+4      	; 0xeba <main+0x26>
            continue;  // Skip to next iteration after handling movement
 eb6:	0e df       	rcall	.-484    	; 0xcd4 <move_elevator>
        }
        
        // Get keypad input (non-blocking)
        uint8_t key = safe_get_keypad_input();
 eb8:	f0 cf       	rjmp	.-32     	; 0xe9a <main+0x6>
        
        // Process keypad input if a key is pressed
        if (key != 0xFF) {
 eba:	1e dc       	rcall	.-1988   	; 0x6f8 <safe_get_keypad_input>
 ebc:	8f 3f       	cpi	r24, 0xFF	; 255
            process_keypad_input(key);
 ebe:	51 f0       	breq	.+20     	; 0xed4 <main+0x40>
 ec0:	e3 dd       	rcall	.-1082   	; 0xa88 <process_keypad_input>
 ec2:	2f ef       	ldi	r18, 0xFF	; 255
 ec4:	84 e3       	ldi	r24, 0x34	; 52
 ec6:	9c e0       	ldi	r25, 0x0C	; 12
 ec8:	21 50       	subi	r18, 0x01	; 1
 eca:	80 40       	sbci	r24, 0x00	; 0
 ecc:	90 40       	sbci	r25, 0x00	; 0
 ece:	e1 f7       	brne	.-8      	; 0xec8 <main+0x34>
 ed0:	00 c0       	rjmp	.+0      	; 0xed2 <main+0x3e>
 ed2:	00 00       	nop
            _delay_ms(250);  // Debounce delay
        }
        
        // Handle fault state (blink LED and return to idle)
        if (current_state == STATE_FAULT) {
 ed4:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <current_state>
 ed8:	85 30       	cpi	r24, 0x05	; 5
            debug_blink(3);
 eda:	f9 f6       	brne	.-66     	; 0xe9a <main+0x6>
 edc:	83 e0       	ldi	r24, 0x03	; 3
 ede:	1b dc       	rcall	.-1994   	; 0x716 <debug_blink>
 ee0:	2f ef       	ldi	r18, 0xFF	; 255
 ee2:	87 ea       	ldi	r24, 0xA7	; 167
 ee4:	91 e6       	ldi	r25, 0x61	; 97
 ee6:	21 50       	subi	r18, 0x01	; 1
 ee8:	80 40       	sbci	r24, 0x00	; 0
 eea:	90 40       	sbci	r25, 0x00	; 0
 eec:	e1 f7       	brne	.-8      	; 0xee6 <main+0x52>
 eee:	00 c0       	rjmp	.+0      	; 0xef0 <main+0x5c>
            _delay_ms(2000);  // Display fault message for 2 seconds
            set_state(STATE_IDLE);
 ef0:	00 00       	nop
 ef2:	80 e0       	ldi	r24, 0x00	; 0
 ef4:	17 dd       	rcall	.-1490   	; 0x924 <set_state>
 ef6:	d1 cf       	rjmp	.-94     	; 0xe9a <main+0x6>

00000ef8 <__tablejump2__>:
 ef8:	ee 0f       	add	r30, r30
 efa:	ff 1f       	adc	r31, r31
 efc:	88 1f       	adc	r24, r24
 efe:	8b bf       	out	0x3b, r24	; 59
 f00:	07 90       	elpm	r0, Z+
 f02:	f6 91       	elpm	r31, Z
 f04:	e0 2d       	mov	r30, r0
 f06:	19 94       	eijmp

00000f08 <__itoa_ncheck>:
 f08:	bb 27       	eor	r27, r27
 f0a:	4a 30       	cpi	r20, 0x0A	; 10
 f0c:	31 f4       	brne	.+12     	; 0xf1a <__itoa_ncheck+0x12>
 f0e:	99 23       	and	r25, r25
 f10:	22 f4       	brpl	.+8      	; 0xf1a <__itoa_ncheck+0x12>
 f12:	bd e2       	ldi	r27, 0x2D	; 45
 f14:	90 95       	com	r25
 f16:	81 95       	neg	r24
 f18:	9f 4f       	sbci	r25, 0xFF	; 255
 f1a:	01 c0       	rjmp	.+2      	; 0xf1e <__utoa_common>

00000f1c <__utoa_ncheck>:
 f1c:	bb 27       	eor	r27, r27

00000f1e <__utoa_common>:
 f1e:	fb 01       	movw	r30, r22
 f20:	55 27       	eor	r21, r21
 f22:	aa 27       	eor	r26, r26
 f24:	88 0f       	add	r24, r24
 f26:	99 1f       	adc	r25, r25
 f28:	aa 1f       	adc	r26, r26
 f2a:	a4 17       	cp	r26, r20
 f2c:	10 f0       	brcs	.+4      	; 0xf32 <__utoa_common+0x14>
 f2e:	a4 1b       	sub	r26, r20
 f30:	83 95       	inc	r24
 f32:	50 51       	subi	r21, 0x10	; 16
 f34:	b9 f7       	brne	.-18     	; 0xf24 <__utoa_common+0x6>
 f36:	a0 5d       	subi	r26, 0xD0	; 208
 f38:	aa 33       	cpi	r26, 0x3A	; 58
 f3a:	08 f0       	brcs	.+2      	; 0xf3e <__utoa_common+0x20>
 f3c:	a9 5d       	subi	r26, 0xD9	; 217
 f3e:	a1 93       	st	Z+, r26
 f40:	00 97       	sbiw	r24, 0x00	; 0
 f42:	79 f7       	brne	.-34     	; 0xf22 <__utoa_common+0x4>
 f44:	b1 11       	cpse	r27, r1
 f46:	b1 93       	st	Z+, r27
 f48:	11 92       	st	Z+, r1
 f4a:	cb 01       	movw	r24, r22
 f4c:	00 c0       	rjmp	.+0      	; 0xf4e <strrev>

00000f4e <strrev>:
 f4e:	dc 01       	movw	r26, r24
 f50:	fc 01       	movw	r30, r24
 f52:	67 2f       	mov	r22, r23
 f54:	71 91       	ld	r23, Z+
 f56:	77 23       	and	r23, r23
 f58:	e1 f7       	brne	.-8      	; 0xf52 <strrev+0x4>
 f5a:	32 97       	sbiw	r30, 0x02	; 2
 f5c:	04 c0       	rjmp	.+8      	; 0xf66 <strrev+0x18>
 f5e:	7c 91       	ld	r23, X
 f60:	6d 93       	st	X+, r22
 f62:	70 83       	st	Z, r23
 f64:	62 91       	ld	r22, -Z
 f66:	ae 17       	cp	r26, r30
 f68:	bf 07       	cpc	r27, r31
 f6a:	c8 f3       	brcs	.-14     	; 0xf5e <strrev+0x10>
 f6c:	08 95       	ret

00000f6e <_exit>:
 f6e:	f8 94       	cli

00000f70 <__stop_program>:
 f70:	ff cf       	rjmp	.-2      	; 0xf70 <__stop_program>
